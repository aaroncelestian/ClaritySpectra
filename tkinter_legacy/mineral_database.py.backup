#!/usr/bin/env python3
# Mineral Database Module for RamanLab
"""
Module for managing a database of mineral Raman modes.
"""

import os
import pickle
import numpy as np
import pandas as pd
import tkinter as tk
from tkinter import ttk, filedialog, messagebox, simpledialog
import matplotlib.pyplot as plt
import matplotlib as mpl
# Configure matplotlib to use DejaVu Sans which supports mathematical symbols
mpl.rcParams['font.family'] = 'DejaVu Sans'
mpl.rcParams['mathtext.fontset'] = 'dejavusans'
from matplotlib.backends.backend_tkagg import FigureCanvasTkAgg, NavigationToolbar2Tk
import random
import json
import subprocess
import sys
import time
import math

class MineralDatabase:
    """Mineral database management system for Raman modes."""
    
    def __init__(self, database_path=None):
        """
        Initialize the mineral database.
        
        Parameters:
        -----------
        database_path : str, optional
            Path to the database file (.pkl)
        """
        self.database_path = database_path or os.path.join(os.path.dirname(__file__), "mineral_modes.pkl")
        self._database = None  # Initialize as None for lazy loading
        self._mineral_list = None  # Cache for mineral list
        self._loaded = False  # Flag to check if database has been loaded
 
        
    def _load_database(self):
        """Load the database from file or create a new one if it doesn't exist."""
        if self._loaded and self._database is not None:
            return self._database
            
        print("Loading mineral database...")
        start_time = time.time()  # Track loading time
        
        if os.path.exists(self.database_path):
            try:
                with open(self.database_path, 'rb') as f:
                    self._database = pickle.load(f)
                self._loaded = True
                load_time = time.time() - start_time
                print(f"Database loaded in {load_time:.2f} seconds with {len(self._database)} minerals.")
                return self._database
            except Exception as e:
                print(f"Error loading database: {e}")
                self._database = {}
                self._loaded = True
                return self._database
        
        self._database = {}
        self._loaded = True
        return self._database
    
    @property
    def database(self):
        """Lazy load the database when first accessed."""
        if not self._loaded:
            return self._load_database()
        return self._database
            
    def save_database(self):
        """Save the database to file."""
        # Make sure database is loaded before saving
        if not self._loaded:
            self._load_database()
            
        try:
            start_time = time.time()
            with open(self.database_path, 'wb') as f:
                pickle.dump(self._database, f)
            save_time = time.time() - start_time
            print(f"Database saved in {save_time:.2f} seconds.")
            
            # Reset cache after saving
            self._mineral_list = None
            return True
        except Exception as e:
            print(f"Error saving database: {e}")
            return False
            
    def get_minerals(self):
        """Get list of all minerals in the database with caching."""
        # Use cached list if available
        if self._mineral_list is not None:
            return self._mineral_list
        
        # Filter out special metadata keys (starting with __) and sort the list
        self._mineral_list = [name for name in self.database.keys() if not name.startswith('__')]
        self._mineral_list.sort()
        return self._mineral_list
        
    def get_mineral_data(self, name):
        """Get data for a specific mineral."""
        return self.database.get(name, None)
        
    def add_mineral(self, name, crystal_system=None, point_group=None, space_group=None):
        """
        Add a new mineral to the database.
        
        Parameters:
        -----------
        name : str
            Name of the mineral
        crystal_system : str, optional
            Crystal system (e.g., cubic, tetragonal)
        point_group : str, optional
            Point group (e.g., Oh, D4h)
        space_group : str, optional
            Space group (e.g., Fm-3m, P21/c)
            
        Returns:
        --------
        bool
            True if successful, False otherwise
        """
        if name in self.database:
            return False
            
        self.database[name] = {
            'name': name,
            'crystal_system': crystal_system,
            'point_group': point_group,
            'space_group': space_group,
            'modes': [],
        }
        return True
        
    def add_mode(self, mineral_name, position, symmetry, intensity=1.0):
        """
        Add a Raman mode to a mineral.
        
        Parameters:
        -----------
        mineral_name : str
            Name of the mineral
        position : float
            Wavenumber (cm-1)
        symmetry : str
            Symmetry character (e.g., A1g, Eg)
        intensity : float, optional
            Relative intensity (default: 1.0)
            
        Returns:
        --------
        bool
            True if successful, False otherwise
        """
        if mineral_name not in self.database:
            return False
            
        mode = (float(position), str(symmetry), float(intensity))
        self.database[mineral_name]['modes'].append(mode)
        return True
        
    def get_minerals(self):
        """Get list of all minerals in the database."""
        return list(self.database.keys())
        
    def get_mineral_data(self, name):
        """Get data for a specific mineral."""
        return self.database.get(name, None)
        
    def get_modes(self, name):
        """Get Raman modes for a specific mineral."""
        print(f"DEBUG: get_modes called for mineral: {name}")
        
        # First, check for conversion cache marker
        conversion_cache_key = f"__converted_{name.replace(' ', '_')}"
        conversion_already_done = conversion_cache_key in self.database
        
        if name in self.database:
            # Look for modes in the standard key
            modes = self.database[name].get('modes', [])
            
            # If modes exist, return them directly without attempting conversion
            if modes and len(modes) > 0:
                print(f"DEBUG: Found {len(modes)} existing modes for {name}, returning without conversion")
                return modes
                
            # If no modes found and conversion hasn't been attempted, try other keys
            if (not modes or len(modes) == 0) and not conversion_already_done:
                print(f"DEBUG: No modes found in 'modes' key for {name}, looking in alternative locations...")
                
                # Check for phonon_modes and attempt conversion
                mineral_data = self.database[name]
                
                # Print all keys to help debug
                print(f"DEBUG: Available keys for {name}: {list(mineral_data.keys())}")
                
                # Attempt to convert phonon modes to Raman modes
                conversion_success = self.convert_phonon_to_raman_modes(name)
                if conversion_success:
                    print(f"DEBUG: Successfully converted phonon modes to Raman modes for {name}")
                    # Get the newly converted modes
                    modes = mineral_data.get('modes', [])
                    
                    # Save the database to persist the converted modes
                    save_success = self.save_database()
                    if save_success:
                        print(f"DEBUG: Database saved after mode conversion for {name}")
                    else:
                        print(f"DEBUG: Failed to save database after mode conversion for {name}")
                else:
                    # If conversion failed, look for modes in various possible keys
                    print(f"DEBUG: Conversion failed or no phonon data found, checking other keys for {name}")
                    for key in ['phonon_modes', 'raman_modes', 'modes_data', 'mode_list', 'peaks']:
                        if key in mineral_data:
                            value = mineral_data[key]
                            print(f"DEBUG: Found potential mode data in key '{key}', type: {type(value)}")
                            
                            # Instead of trying to convert automatically, just log the info
                            if isinstance(value, pd.DataFrame):
                                print(f"DEBUG: DataFrame found in '{key}' with shape {value.shape}")
                                print(f"DEBUG: Cannot auto-convert DataFrame to modes - try using add_example_modes")
                            elif isinstance(value, list) and len(value) > 0:
                                print(f"DEBUG: List found in '{key}' with {len(value)} items")
                                print(f"DEBUG: First item type: {type(value[0])}")
                                # Don't try auto-conversion here
            
            print(f"DEBUG: Returning {len(modes)} modes for {name}")
            return modes
        else:
            print(f"DEBUG: Mineral {name} not found in database")
        return []
        
    def import_from_peak_fitting(self, mineral_name, peak_data):
        """
        Import peak data from peak_fitting.py output.
        
        Parameters:
        -----------
        mineral_name : str
            Name of the mineral to add/update
        peak_data : list
            List of peak data from peak fitting
            
        Returns:
        --------
        bool
            True if successful, False otherwise
        """
        if mineral_name not in self.database:
            self.add_mineral(mineral_name)
            
        for peak in peak_data:
            position = peak.get('position', 0)
            # Default to A1g symmetry if not specified
            symmetry = peak.get('symmetry', 'A1g')
            intensity = peak.get('amplitude', 1.0)
            self.add_mode(mineral_name, position, symmetry, intensity)
            
        return True
        
    def import_from_pkl(self, file_path):
        """
        Import data from another pickle file.
        
        Parameters:
        -----------
        file_path : str
            Path to the pickle file
            
        Returns:
        --------
        int
            Number of minerals imported
        """
        try:
            with open(file_path, 'rb') as f:
                imported_data = pickle.load(f)
                
            if not isinstance(imported_data, dict):
                return 0
                
            count = 0
            for name, data in imported_data.items():
                if name not in self.database:
                    self.database[name] = data
                    count += 1
                    
            return count
        except Exception as e:
            print(f"Error importing database: {e}")
            return 0

    def delete_mineral(self, name):
        """
        Delete a mineral from the database.
        
        Parameters:
        -----------
        name : str
            Name of the mineral to delete
            
        Returns:
        --------
        bool
            True if mineral was deleted, False if mineral not found
        """
        if name in self.database:
            del self.database[name]
            # Clear mineral list cache after deletion
            self._mineral_list = None
            return True
        return False

    def import_from_csv(self, mineral_name, csv_type, file_path):
        """
        Import data from CSV files (dielectric_tensors, born_charges, info).
        
        Parameters:
        -----------
        mineral_name : str
            Name of the mineral to add/update
        csv_type : str
            Type of CSV data ('dielectric_tensors', 'born_charges', 'info')
        file_path : str
            Path to the CSV file
            
        Returns:
        --------
        bool
            True if successful, False otherwise
        """
        try:
            # Create the mineral if it doesn't exist
            if mineral_name not in self.database:
                self.add_mineral(mineral_name)
            
            # Load the CSV file
            df = pd.read_csv(file_path)
            
            # Process based on CSV type
            if csv_type == 'dielectric_tensors':
                # Extract the dielectric tensor
                dielectric_tensor = []
                if 'Ɛ∞' in ' '.join(df['Tensor']):
                    # Create a 3x3 dielectric tensor
                    e_inf = np.zeros((3, 3))
                    for i, row in df[df['Tensor'] == 'Ɛ∞'].iterrows():
                        comp = row['Component'].lower()
                        idx1 = 0 if 'xx' in comp else (1 if 'yy' in comp else 2)
                        idx2 = 0 if 'xx' in comp else (1 if 'yy' in comp else 2)
                        e_inf[idx1, idx2] = float(row['X'])
                        if 'Y' in df.columns and not pd.isna(row['Y']):
                            e_inf[idx1, 1] = float(row['Y'])
                        if 'Z' in df.columns and not pd.isna(row['Z']):
                            e_inf[idx1, 2] = float(row['Z'])
                    
                    dielectric_tensor = e_inf.tolist()
                
                # Store the tensor in the database
                if dielectric_tensor:
                    self.database[mineral_name]['dielectric_tensor'] = dielectric_tensor
                
                # Store the entire dataframe for future reference
                self.database[mineral_name]['dielectric_tensor_full'] = df
                
                return True
                
            elif csv_type == 'born_charges':
                # Extract Born charges
                born_charges = []
                atoms = df['Atom'].unique()
                
                for atom in atoms:
                    atom_data = df[df['Atom'] == atom]
                    
                    # Group rows for each unique atom
                    charges = []
                    for i in range(0, len(atom_data), 3):  # Each atom has 3 rows (xx, yy, zz)
                        atom_charge = np.zeros((3, 3))
                        for j in range(3):
                            if i+j < len(atom_data):
                                row = atom_data.iloc[i+j]
                                comp = row['Component'].lower()
                                idx1 = 0 if 'xx' in comp else (1 if 'yy' in comp else 2)
                                atom_charge[idx1, 0] = float(row['X'])
                                atom_charge[idx1, 1] = float(row['Y']) if 'Y' in df.columns and not pd.isna(row['Y']) else 0.0
                                atom_charge[idx1, 2] = float(row['Z']) if 'Z' in df.columns and not pd.isna(row['Z']) else 0.0
                        
                        charges.append(atom_charge.tolist())
                    
                    born_charges.append({
                        'atom': atom,
                        'charge': charges[0] if charges else []
                    })
                
                # Store the Born charges in the database
                if born_charges:
                    self.database[mineral_name]['born_charges'] = born_charges
                
                # Store the entire dataframe for future reference
                self.database[mineral_name]['born_charges_full'] = df
                
                return True
                
            elif csv_type == 'info':
                # Extract mineral information
                if not df.empty:
                    row = df.iloc[0]
                    
                    # Update space group information
                    if 'experimental_symmetry_space_group_symbol' in row:
                        space_group = row['experimental_symmetry_space_group_symbol']
                        if pd.notna(space_group):
                            self.database[mineral_name]['space_group'] = space_group
                    
                    # Derive crystal system from space group number or symbol
                    if 'experimental_symmetry_space_group_number' in row:
                        sg_number = row['experimental_symmetry_space_group_number']
                        if pd.notna(sg_number):
                            # Pass the raw space group number to _derive_crystal_system
                            # which will handle conversion and special cases
                            crystal_system = self._derive_crystal_system(sg_number)
                            if crystal_system:
                                self.database[mineral_name]['crystal_system'] = crystal_system
                    
                    # Derive point group from space group
                    if 'experimental_symmetry_space_group_symbol' in row:
                        sg_symbol = row['experimental_symmetry_space_group_symbol']
                        if pd.notna(sg_symbol):
                            point_group = self._derive_point_group(sg_symbol)
                            if point_group:
                                self.database[mineral_name]['point_group'] = point_group
                    
                    # Store chemical formula
                    if 'chemical_formula' in row:
                        formula = row['chemical_formula']
                        if pd.notna(formula):
                            self.database[mineral_name]['chemical_formula'] = formula
                
                # Store the entire dataframe for future reference
                self.database[mineral_name]['info_full'] = df
                
                return True
                
            return False
            
        except Exception as e:
            print(f"Error importing CSV: {e}")
            import traceback
            traceback.print_exc()
            return False
            
    def _derive_crystal_system(self, space_group_number):
        """Derive crystal system from space group number."""
        # Skip the entire conversion process if we're not given a valid input
        if space_group_number is None:
            return ""
            
        # If space_group_number is a string, try to extract numeric value
        if isinstance(space_group_number, str):
            # Handle special cases first
            if 'xx' in space_group_number.lower():
                return ""  # Invalid space group
                
            import re
            # Look for patterns like "Exp 176, Theo 173" or "Theo 14" and extract the first number
            match = re.search(r'(\d+)', space_group_number)
            if match:
                try:
                    # Extract the first numeric value found
                    space_group_number = int(match.group(1))
                except (ValueError, TypeError):
                    return ""
            else:
                return ""
                
        # Now process the numeric space group
        try:
            space_group_number = int(space_group_number)
            if 1 <= space_group_number <= 2:
                return "Triclinic"
            elif 3 <= space_group_number <= 15:
                return "Monoclinic"
            elif 16 <= space_group_number <= 74:
                return "Orthorhombic"
            elif 75 <= space_group_number <= 142:
                return "Tetragonal"
            elif 143 <= space_group_number <= 167:
                return "Trigonal"
            elif 168 <= space_group_number <= 194:
                return "Hexagonal"
            elif 195 <= space_group_number <= 230:
                return "Cubic"
        except (ValueError, TypeError):
            # If conversion still fails, don't raise an error, just return empty string
            pass
            
        return ""
        
    def _derive_point_group(self, space_group_symbol):
        """Derive point group from space group symbol."""
        # Extended mapping from space group to point group
        sg_to_pg = {
            'P1': '1', 'P-1': '-1',  # Triclinic
            'P2': '2', 'P21': '2', 'C2': '2', 'Pm': 'm', 'Pc': 'm', 'Cm': 'm', 'Cc': 'm',
            'P2/m': '2/m', 'P21/m': '2/m', 'C2/m': '2/m', 'P2/c': '2/m', 'P21/c': '2/m', 'C2/c': '2/m',  # Monoclinic
            'P222': '222', 'P2221': '222', 'Pmmm': 'mmm', 'Pnma': 'mmm',  # Orthorhombic
            'P4': '4', '-4': '-4', 'P4/m': '4/m', 'P422': '422', 'P4mm': '4mm', 'P-42m': '-42m', 'P4/mmm': '4/mmm',  # Tetragonal
            'P3': '3', '-3': '-3', 'P321': '32', 'P3m1': '3m', 'P-3m1': '-3m',  # Trigonal
            'R-3c': '3m', 'R3c': '3m', 'R-3': '-3', 'R3': '3', 'R32': '32', 'R3m': '3m', 'R-3m': '-3m',
            'P6': '6', 'P-6': '-6', 'P6/m': '6/m', 'P622': '622', 'P6mm': '6mm', 'P-6m2': '-6m2', 'P6/mmm': '6/mmm',  # Hexagonal
            'P23': '23', 'P213': '23', 'Pm-3': 'm-3', 'Pn-3': 'm-3',
            'P432': '432', 'P-43m': '-43m', 'Pm-3m': 'm-3m', 'Pn-3m': 'm-3m', 'Fm-3m': 'm-3m', 'Fd-3m': 'm-3m',  # Cubic
        }
        # Try to find a direct match (case-insensitive, ignore spaces)
        sg_symbol_clean = space_group_symbol.replace(' ', '').upper()
        for sg, pg in sg_to_pg.items():
            if sg_symbol_clean == sg.replace(' ', '').upper():
                return pg
        # Fallback: handle common trigonal/hexagonal rhombohedral cases
        if sg_symbol_clean.startswith('R-3C') or sg_symbol_clean.startswith('R3C'):
            return '3m'
        if sg_symbol_clean.startswith('R-3M') or sg_symbol_clean.startswith('R3M'):
            return '-3m'
        if sg_symbol_clean.startswith('R-3') or sg_symbol_clean.startswith('R3'):
            return '-3'
        # Fallback: try to extract the point group from the symbol (very basic)
        if sg_symbol_clean.startswith('P3') or sg_symbol_clean.startswith('R3'):
            return '3'
        if sg_symbol_clean.startswith('P6'):
            return '6'
        if sg_symbol_clean.startswith('P4'):
            return '4'
        if sg_symbol_clean.startswith('P2'):
            return '2'
        if sg_symbol_clean.startswith('P1'):
            return '1'
        # If no match, return empty string
        return ""

    def convert_phonon_to_raman_modes(self, mineral_name):
        """Convert phonon modes to Raman modes format."""
        try:
            # Get mineral data without triggering auto-conversion
            mineral_data = self.database.get(mineral_name)
            if not mineral_data:
                print(f"DEBUG: No mineral data found for '{mineral_name}'")
                return False
                
            print(f"DEBUG: Converting phonon modes for '{mineral_name}'")
            
            # IMPORTANT: Create a unique cache key for checking if this conversion has been done
            conversion_cache_key = f"__converted_{mineral_name.replace(' ', '_')}"
            if conversion_cache_key in self.database:
                print(f"DEBUG: Conversion already performed for '{mineral_name}', skipping")
                return True
                
            # Check if modes already exist and have data - if so, skip conversion 
            if 'modes' in mineral_data and isinstance(mineral_data['modes'], list) and len(mineral_data['modes']) > 0:
                print(f"DEBUG: '{mineral_name}' already has {len(mineral_data['modes'])} modes, skipping conversion")
                
                # Mark this mineral as having been converted (if not already marked)
                if conversion_cache_key not in self.database:
                    print(f"DEBUG: Marking '{mineral_name}' as already converted")
                    self.database[conversion_cache_key] = True
                
                return True
            
            # Import pandas for dataframe operations only when needed
            import pandas as pd
            import numpy as np
            
            # Check for phonon modes in different possible keys - use a more efficient approach
            phonon_modes = None
            potential_keys = ['phonon_modes', 'phonon_mode', 'phonons', 'modes_full', 'all_modes']
            
            # First try to find any valid phonon data
            for key in potential_keys:
                if key in mineral_data:
                    value = mineral_data[key]
                    
                    # Handle DataFrames specifically
                    if isinstance(value, pd.DataFrame):
                        if not value.empty:
                            try:
                                phonon_modes = value.to_dict('records')
                                print(f"DEBUG: Converted DataFrame in '{key}' to {len(phonon_modes)} records")
                                break
                            except Exception as e:
                                print(f"DEBUG: Error converting DataFrame in '{key}': {e}")
                                continue
                    elif value:  # Non-empty list, dict, etc.
                        phonon_modes = value
                        print(f"DEBUG: Found phonon modes in key '{key}', count: {len(phonon_modes) if hasattr(phonon_modes, '__len__') else 'unknown'}")
                        break
            
            # If no valid phonon modes found through standard keys, look for mode-like data in any key
            if phonon_modes is None:
                for key, value in mineral_data.items():
                    if isinstance(value, list) and value and isinstance(value[0], dict) and any(k in value[0] for k in ['frequency', 'position', 'mode']):
                        phonon_modes = value
                        print(f"DEBUG: Found potential mode data in key '{key}', count: {len(phonon_modes)}")
                        break
            
            # If still no modes found, return failure
            if phonon_modes is None:
                print(f"DEBUG: No phonon mode data found for '{mineral_name}' under any key")
                return False
            
            # Initialize modes list
            if 'modes' not in mineral_data:
                mineral_data['modes'] = []
                
            # Process modes more efficiently
            modes_added = 0
            processed_frequencies = set()  # Track already processed frequencies to avoid duplicates
            
            for mode in phonon_modes:
                try:
                    # Get frequency/position (try multiple possible keys efficiently)
                    pos = None
                    if isinstance(mode, dict):
                        # Try common keys in order of likelihood
                        for key in ['frequency', 'position', 'freq', 'wavenumber', 'TO_Frequency', 'Frequency']:
                            if key in mode:
                                try:
                                    pos = float(mode[key])
                                    break
                                except (ValueError, TypeError):
                                    # Try to extract number from string
                                    try:
                                        import re
                                        match = re.search(r'(\d+\.?\d*)', str(mode[key]))
                                        if match:
                                            pos = float(match.group(1))
                                            break
                                    except:
                                        pass
                    
                        # Try Mode field with frequency in parentheses
                        if pos is None and 'Mode' in mode and isinstance(mode['Mode'], str):
                            import re
                            match = re.search(r'\((\d+\.?\d*)\)', mode['Mode'])
                            if match:
                                pos = float(match.group(1))
                
                    # Skip if no valid position/frequency found
                    if pos is None:
                        continue
                        
                    # Skip duplicate frequencies (within a small tolerance)
                    duplicate = False
                    for existing_pos in processed_frequencies:
                        if abs(existing_pos - pos) < 0.5:  # 0.5 cm-1 tolerance
                            duplicate = True
                            break
                    if duplicate:
                        continue
                        
                    # Extract symmetry - prioritize specific fields
                    sym = None
                    for key in ['Activity', 'symmetry', 'sym', 'irrep', 'mode_symmetry', 'character', 'Mode']:
                        if key in mode:
                            try:
                                value = str(mode[key])
                                if key == 'Mode' and isinstance(value, str):
                                    # Extract symmetry part
                                    import re
                                    match = re.search(r'(A1g|A2g|B1g|B2g|Eg|A1u|A2u|B1u|B2u|Eu|A1|A2|B1|B2|E|T1g|T2g|T1u|T2u)', value)
                                    if match:
                                        sym = match.group(1)
                                    else:
                                        sym = value.split('(')[0].strip()
                                else:
                                    sym = value
                                if sym:
                                    break
                            except:
                                pass
                    
                    # Default symmetry if not found
                    if not sym:
                        sym = "A1g"
                    
                    # Get intensity - prioritize specific fields
                    intensity = None
                    for key in ['I_Total', 'intensity', 'raman_intensity', 'int', 'raman_int', 'amplitude']:
                        if key in mode:
                            try:
                                val = mode[key]
                                if val is not None:
                                    intensity = float(val)
                                    break
                            except:
                                pass
                    
                    # Default intensity if not found
                    if intensity is None or intensity <= 0:
                        # Check activity to determine default intensity
                        activity = None
                        for key in ['activity', 'Activity']:
                            if key in mode:
                                activity = str(mode[key]).lower()
                                break
                                
                        if activity and 'raman' in activity:
                            intensity = 0.75  # Default for Raman active modes
                        elif activity and 'ir' in activity:
                            intensity = 0.1   # Lower intensity for IR modes
                        else:
                            intensity = 0.3   # General default intensity
                    
                    # Add the mode
                    mineral_data['modes'].append((pos, sym, intensity))
                    processed_frequencies.add(pos)
                    modes_added += 1
                    
                except Exception as e:
                    print(f"DEBUG: Error processing mode: {e}")
                    continue
            
            # Sort the modes by position (ascending)
            if mineral_data['modes']:
                mineral_data['modes'].sort(key=lambda x: x[0])
            
            # Set conversion cache flag to avoid repeat conversions
            if modes_added > 0:
                self.database[conversion_cache_key] = True
                
            print(f"DEBUG: Added {modes_added} modes for '{mineral_name}'")
            return modes_added > 0
            
        except Exception as e:
            print(f"DEBUG ERROR: Exception in convert_phonon_to_raman_modes for '{mineral_name}': {str(e)}")
            import traceback
            traceback.print_exc()
            return False

    def search_minerals(self, search_term):
        """
        Search for minerals matching the search term.
        
        Parameters:
        -----------
        search_term : str
            Search term to match against mineral names and other properties.
            
        Returns:
        --------
        list
            List of matching mineral names
        """
        # Convert search_term to string to prevent errors with numeric inputs
        search_term = str(search_term).lower()
        results = []
        
        # Search in mineral names and attributes
        for name in self.database.keys():
            # Skip special metadata keys (conversion cache markers start with __)
            if name.startswith('__'):
                continue
                
            # Check name
            if search_term in name.lower():
                results.append(name)
                continue
                
            # Get mineral data
            mineral_data = self.database[name]
            
            # Skip if mineral_data is not a dictionary
            if not isinstance(mineral_data, dict):
                continue
                
            # Check chemical formula if available
            if 'chemical_formula' in mineral_data and mineral_data['chemical_formula']:
                formula = str(mineral_data['chemical_formula']).lower()
                if search_term in formula:
                    results.append(name)
                    continue
            
            # Check crystal system if available
            if 'crystal_system' in mineral_data and mineral_data['crystal_system']:
                crystal_system = str(mineral_data['crystal_system']).lower()
                if search_term in crystal_system:
                    results.append(name)
                    continue
                    
            # Check space group if available
            if 'space_group' in mineral_data and mineral_data['space_group']:
                space_group = str(mineral_data['space_group']).lower()
                if search_term in space_group:
                    results.append(name)
                    continue
        
        return results

    def get_default_crystal_model(self, mineral_name):
        """
        Generate a default crystal model based on the crystal system.
        Returns dictionary with vertices, edges, and default orientation.
        
        Parameters:
        -----------
        mineral_name : str
            Name of the mineral
            
        Returns:
        --------
        dict
            Crystal model with vertices, edges, and orientation information
        """
        mineral_data = self.get_mineral_data(mineral_name)
        if not mineral_data:
            return None
            
        crystal_system = mineral_data.get('crystal_system', '').lower()
        
        # Default model with no specific shape
        model = {
            'vertices': [],
            'edges': [],
            'faces': [],
            'crystal_system': crystal_system,
            'point_group': mineral_data.get('point_group', ''),
            'space_group': mineral_data.get('space_group', ''),
            'default_orientation': {'alpha': 0, 'beta': 0, 'gamma': 0}
        }
        
        # Generate vertices and edges based on crystal system
        if 'cubic' in crystal_system:
            # Simple cube for cubic system
            a = 1.0  # Unit length
            vertices = [
                [-a/2, -a/2, -a/2], [a/2, -a/2, -a/2], [a/2, a/2, -a/2], [-a/2, a/2, -a/2],
                [-a/2, -a/2, a/2], [a/2, -a/2, a/2], [a/2, a/2, a/2], [-a/2, a/2, a/2]
            ]
            edges = [
                [0, 1], [1, 2], [2, 3], [3, 0],  # Bottom face
                [4, 5], [5, 6], [6, 7], [7, 4],  # Top face
                [0, 4], [1, 5], [2, 6], [3, 7]   # Connecting edges
            ]
            model['vertices'] = vertices
            model['edges'] = edges
            model['axes'] = {'a': [1, 0, 0], 'b': [0, 1, 0], 'c': [0, 0, 1]}
            
        elif 'tetragonal' in crystal_system:
            # Tetragonal prism
            a = 1.0
            c = 1.5  # c axis typically longer
            vertices = [
                [-a/2, -a/2, -c/2], [a/2, -a/2, -c/2], [a/2, a/2, -c/2], [-a/2, a/2, -c/2],
                [-a/2, -a/2, c/2], [a/2, -a/2, c/2], [a/2, a/2, c/2], [-a/2, a/2, c/2]
            ]
            edges = [
                [0, 1], [1, 2], [2, 3], [3, 0],  # Bottom face
                [4, 5], [5, 6], [6, 7], [7, 4],  # Top face
                [0, 4], [1, 5], [2, 6], [3, 7]   # Connecting edges
            ]
            model['vertices'] = vertices
            model['edges'] = edges
            model['axes'] = {'a': [1, 0, 0], 'b': [0, 1, 0], 'c': [0, 0, 1]}
            
        elif 'hexagonal' in crystal_system or 'trigonal' in crystal_system:
            # Hexagonal prism
            a = 1.0
            c = 1.6  # c axis typically longer
            
            # Create a regular hexagon for the base
            import math
            vertices = []
            for i in range(6):
                angle = 2 * math.pi * i / 6
                x = a * math.cos(angle)
                y = a * math.sin(angle)
                vertices.append([x, y, -c/2])  # Bottom face
            
            for i in range(6):
                angle = 2 * math.pi * i / 6
                x = a * math.cos(angle)
                y = a * math.sin(angle)
                vertices.append([x, y, c/2])   # Top face
            
            # Create edges
            edges = []
            for i in range(6):
                edges.append([i, (i+1)%6])           # Bottom hexagon
                edges.append([i+6, ((i+1)%6)+6])     # Top hexagon
                edges.append([i, i+6])               # Connecting edges
            
            model['vertices'] = vertices
            model['edges'] = edges
            
            # Standard orientation: c axis along z, a in xy plane
            model['axes'] = {'a': [1, 0, 0], 'b': [-0.5, 0.866, 0], 'c': [0, 0, 1]}
            
        elif 'orthorhombic' in crystal_system:
            # Orthorhombic prism (rectangle)
            a, b, c = 1.0, 1.3, 1.7  # Three different lengths
            vertices = [
                [-a/2, -b/2, -c/2], [a/2, -b/2, -c/2], [a/2, b/2, -c/2], [-a/2, b/2, -c/2],
                [-a/2, -b/2, c/2], [a/2, -b/2, c/2], [a/2, b/2, c/2], [-a/2, b/2, c/2]
            ]
            edges = [
                [0, 1], [1, 2], [2, 3], [3, 0],  # Bottom face
                [4, 5], [5, 6], [6, 7], [7, 4],  # Top face
                [0, 4], [1, 5], [2, 6], [3, 7]   # Connecting edges
            ]
            model['vertices'] = vertices
            model['edges'] = edges
            model['axes'] = {'a': [1, 0, 0], 'b': [0, 1, 0], 'c': [0, 0, 1]}
            
        elif 'monoclinic' in crystal_system:
            # Monoclinic prism (with beta angle ≠ 90°)
            a, b, c = 1.0, 1.2, 1.4
            beta = 105 * (math.pi / 180)  # ~105° is common for monoclinic
            
            # Create vertices with beta angle between a and c
            sin_beta = math.sin(beta)
            cos_beta = math.cos(beta)
            
            vertices = [
                [-a/2, -b/2, -c/2], [a/2, -b/2, -c/2], [a/2, b/2, -c/2], [-a/2, b/2, -c/2],
                [-a/2 + c*cos_beta, -b/2, c*sin_beta - c/2], 
                [a/2 + c*cos_beta, -b/2, c*sin_beta - c/2],
                [a/2 + c*cos_beta, b/2, c*sin_beta - c/2],
                [-a/2 + c*cos_beta, b/2, c*sin_beta - c/2]
            ]
            edges = [
                [0, 1], [1, 2], [2, 3], [3, 0],  # Bottom face
                [4, 5], [5, 6], [6, 7], [7, 4],  # Top face
                [0, 4], [1, 5], [2, 6], [3, 7]   # Connecting edges
            ]
            model['vertices'] = vertices
            model['edges'] = edges
            model['axes'] = {'a': [1, 0, 0], 'b': [0, 1, 0], 'c': [cos_beta, 0, sin_beta]}
            model['default_orientation'] = {'alpha': 0, 'beta': beta * (180/math.pi), 'gamma': 0}
            
        elif 'triclinic' in crystal_system:
            # Triclinic crystal (all angles ≠ 90°)
            a, b, c = 1.0, 1.1, 1.3
            alpha = 95 * (math.pi / 180)  # ~95° between b and c
            beta = 105 * (math.pi / 180)  # ~105° between a and c
            gamma = 85 * (math.pi / 180)  # ~85° between a and b
            
            # This is a simplified triclinic cell representation
            sin_alpha = math.sin(alpha)
            cos_alpha = math.cos(alpha)
            sin_beta = math.sin(beta)
            cos_beta = math.cos(beta)
            sin_gamma = math.sin(gamma)
            cos_gamma = math.cos(gamma)
            
            # Create a general triclinic cell (simplified)
            vertices = [
                [0, 0, 0], 
                [a, 0, 0], 
                [a + b*cos_gamma, b*sin_gamma, 0], 
                [b*cos_gamma, b*sin_gamma, 0],
                [c*cos_beta, c*cos_alpha*sin_beta, c*sin_alpha*sin_beta], 
                [a + c*cos_beta, c*cos_alpha*sin_beta, c*sin_alpha*sin_beta],
                [a + b*cos_gamma + c*cos_beta, b*sin_gamma + c*cos_alpha*sin_beta, c*sin_alpha*sin_beta],
                [b*cos_gamma + c*cos_beta, b*sin_gamma + c*cos_alpha*sin_beta, c*sin_alpha*sin_beta]
            ]
            edges = [
                [0, 1], [1, 2], [2, 3], [3, 0],  # Bottom face
                [4, 5], [5, 6], [6, 7], [7, 4],  # Top face
                [0, 4], [1, 5], [2, 6], [3, 7]   # Connecting edges
            ]
            model['vertices'] = vertices
            model['edges'] = edges
            model['axes'] = {
                'a': [1, 0, 0], 
                'b': [cos_gamma, sin_gamma, 0], 
                'c': [cos_beta, cos_alpha*sin_beta, sin_alpha*sin_beta]
            }
            model['default_orientation'] = {
                'alpha': alpha * (180/math.pi), 
                'beta': beta * (180/math.pi), 
                'gamma': gamma * (180/math.pi)
            }
            
        else:
            # Default to a simple cube if crystal system is unknown
            a = 1.0
            vertices = [
                [-a/2, -a/2, -a/2], [a/2, -a/2, -a/2], [a/2, a/2, -a/2], [-a/2, a/2, -a/2],
                [-a/2, -a/2, a/2], [a/2, -a/2, a/2], [a/2, a/2, a/2], [-a/2, a/2, a/2]
            ]
            edges = [
                [0, 1], [1, 2], [2, 3], [3, 0],  # Bottom face
                [4, 5], [5, 6], [6, 7], [7, 4],  # Top face
                [0, 4], [1, 5], [2, 6], [3, 7]   # Connecting edges
            ]
            model['vertices'] = vertices
            model['edges'] = edges
            model['axes'] = {'a': [1, 0, 0], 'b': [0, 1, 0], 'c': [0, 0, 1]}
        
        # Add centers for drawing reference axes
        model['center'] = [0, 0, 0]
        
        # Store this model in the mineral data for future use
        mineral_data['crystal_model'] = model
        self.save_database()
        
        return model

    def update_eigenvectors(self, csv_dir="wurm_data/csv"):
        """
        Update eigenvectors for minerals from CSV files in the specified directory.
        
        This method updates both the dielectric tensor and born charges eigenvectors
        for all minerals where corresponding CSV files are found.
        
        Parameters:
        -----------
        csv_dir : str, optional
            Path to the directory containing the CSV files
            Files should be named MINERAL_born_charges.csv and MINERAL_dielectric_tensors.csv
            
        Returns:
        --------
        tuple
            (processed_count, updated_born, updated_dielectric) - counts of updated entries
        """
        # Make sure the database is loaded
        if not self._loaded:
            self._load_database()
            
        print("Starting eigenvector update process...")
        processed_count = 0
        updated_dielectric = 0
        updated_born = 0
        
        # Get all minerals in the database
        minerals = self.get_minerals()
        total_minerals = len(minerals)
        print(f"Found {total_minerals} minerals in the database")
        
        # Process each mineral
        for i, mineral in enumerate(minerals):
            # Skip special entries that start with "__"
            if mineral.startswith('__'):
                continue
                
            # Get mineral data
            mineral_data = self.get_mineral_data(mineral)
            if not isinstance(mineral_data, dict):
                continue
                
            # Create the mineral name for file lookup (uppercase and replace spaces with underscores)
            mineral_base = mineral.upper().replace(" ", "_")
            
            # For user feedback
            if (i+1) % 10 == 0 or i+1 == total_minerals:
                print(f"Processing mineral {i+1}/{total_minerals}: {mineral}")
            
            # --- Update Born Charges ---
            born_csv = os.path.join(csv_dir, f"{mineral_base}_born_charges.csv")
            if os.path.exists(born_csv):
                try:
                    df = pd.read_csv(born_csv)
                    
                    # Group by atom, take first occurrence of each (xx, yy, zz triplet)
                    eigenv_dict = {}
                    for atom in df['Atom'].unique():
                        atom_rows = df[df['Atom'] == atom]
                        # Get the first xx component row for each atom
                        xx_rows = atom_rows[atom_rows['Component'] == 'xx']
                        if not xx_rows.empty:
                            first_row = xx_rows.iloc[0]
                            # Check if Eig columns exist
                            if all(col in first_row.index for col in ['Eig1', 'Eig2', 'Eig3']):
                                eigenv = [float(first_row['Eig1']), float(first_row['Eig2']), float(first_row['Eig3'])]
                                eigenv_dict.setdefault(atom, []).append(eigenv)
                    
                    # Now update the database if we have born_charges
                    if 'born_charges' in mineral_data and eigenv_dict:
                        born_updated = False
                        
                        # If born_charges is a DataFrame, convert to list of dicts
                        if isinstance(mineral_data['born_charges'], pd.DataFrame):
                            try:
                                mineral_data['born_charges'] = mineral_data['born_charges'].to_dict('records')
                            except:
                                # If conversion fails, create empty list
                                mineral_data['born_charges'] = []
                        
                        # Ensure it's a list
                        if not isinstance(mineral_data['born_charges'], list):
                            mineral_data['born_charges'] = []
                        
                        # Update each atom entry
                        for atom_entry in mineral_data['born_charges']:
                            if isinstance(atom_entry, dict) and 'atom' in atom_entry:
                                atom_name = atom_entry['atom']
                                if atom_name in eigenv_dict:
                                    atom_entry['EigenV'] = eigenv_dict[atom_name][0]  # Use first set of eigenvectors
                                    born_updated = True
                        
                        if born_updated:
                            updated_born += 1
                except Exception as e:
                    print(f"Error processing {born_csv}: {e}")
            
            # --- Update Dielectric Tensor ---
            diel_csv = os.path.join(csv_dir, f"{mineral_base}_dielectric_tensors.csv")
            if os.path.exists(diel_csv):
                try:
                    df = pd.read_csv(diel_csv)
                    
                    # Only use the rows where Tensor == 'Ɛ∞'
                    diel_rows = df[df['Tensor'] == 'Ɛ∞']
                    
                    # Get the eigenvectors for xx, yy, zz
                    eigenv = []
                    if not diel_rows.empty:
                        for comp in ['xx', 'yy', 'zz']:
                            row = diel_rows[diel_rows['Component'] == comp]
                            if not row.empty:
                                row = row.iloc[0]
                                if all(col in row.index for col in ['Eig1', 'Eig2', 'Eig3']):
                                    eigenv.append([float(row['Eig1']), float(row['Eig2']), float(row['Eig3'])])
                    
                    # Update the database if we have eigenvectors
                    if eigenv and len(eigenv) == 3:
                        if 'dielectric_tensor' in mineral_data:
                            # Convert to dict if it's a numpy array
                            if isinstance(mineral_data['dielectric_tensor'], np.ndarray):
                                mineral_data['dielectric_tensor'] = {'tensor': mineral_data['dielectric_tensor'].tolist()}
                            
                            # Convert to dict if it's a list
                            if isinstance(mineral_data['dielectric_tensor'], list):
                                mineral_data['dielectric_tensor'] = {'tensor': mineral_data['dielectric_tensor']}
                            
                            # Now add the eigenvectors
                            if isinstance(mineral_data['dielectric_tensor'], dict):
                                mineral_data['dielectric_tensor']['EigenV'] = eigenv
                                updated_dielectric += 1
                        else:
                            # Create new dielectric tensor entry
                            mineral_data['dielectric_tensor'] = {'EigenV': eigenv}
                            updated_dielectric += 1
                except Exception as e:
                    print(f"Error processing {diel_csv}: {e}")
            
            # Count as processed if we updated either born charges or dielectric tensor
            if os.path.exists(born_csv) or os.path.exists(diel_csv):
                processed_count += 1
        
        # Save the database after all updates
        print(f"Saving updates to database...")
        success = self.save_database()
        
        # Print summary
        print("\nEigenvector Update Summary:")
        print(f"Total minerals processed: {processed_count}/{total_minerals}")
        print(f"Updated Born charges: {updated_born}")
        print(f"Updated Dielectric tensors: {updated_dielectric}")
        print(f"Database save {'successful' if success else 'failed'}")
        
        return (processed_count, updated_born, updated_dielectric)

class MineralDatabaseGUI:
    """Modern GUI for mineral database management with advanced search and filtering."""
    def __init__(self, parent=None):
        """Initialize the database GUI."""
        self.db = MineralDatabase()
        
        # Initialize Hey Classification Manager
        self.hey_manager = HeyClassificationManager()
        
        # Create window if no parent is provided
        if parent is None:
            # This is the root window for standalone use
            self.is_standalone = True
            self.window = tk.Tk()
        else:
            # This is being called from another application
            self.is_standalone = False
            # If parent is already a Toplevel window, use it directly
            if isinstance(parent, tk.Toplevel):
                self.window = parent
            else:
                self.window = tk.Toplevel(parent)
            
        # Set window properties
        self.window.title("RamanLab - Mineral Database Browser")
        self.window.geometry("1400x900")
        self.window.minsize(1200, 700)
            
        # Set the 'clam' theme to make the GUI consistent with other windows
        self.style = ttk.Style(self.window)
        self.style.theme_use('clam')
        
        # Configure styling
        self.style.configure('TLabelframe', borderwidth=1)
        self.style.configure('Heading.TLabel', font=('TkDefaultFont', 10, 'bold'))
        
        # Initialize variables
        self.current_mineral = None
        self.filtered_minerals = []
        self._gui_initialized = False  # Flag to prevent callbacks during initialization
        
        # Create GUI
        self.create_gui()
        
        # Mark GUI as fully initialized
        self._gui_initialized = True
        

        
    def create_gui(self):
        """Create the modern GUI elements."""
        # Main frame with padding
        main_frame = ttk.Frame(self.window, padding=10)
        main_frame.pack(fill=tk.BOTH, expand=True)
        
        # Create main paned window for resizable sections
        self.main_paned = ttk.PanedWindow(main_frame, orient=tk.HORIZONTAL)
        self.main_paned.pack(fill=tk.BOTH, expand=True)
        
        # Left panel - Search and filters (30% width)
        self.left_panel = ttk.Frame(self.main_paned, padding=5)
        self.main_paned.add(self.left_panel, weight=1)
        
        # Right panel - Details and visualization (70% width)
        self.right_panel = ttk.Frame(self.main_paned, padding=5)
        self.main_paned.add(self.right_panel, weight=2)
        
        # Create left panel content
        self.create_search_panel()
        
        # Create right panel content
        self.create_details_panel()
        
        # Initialize the mineral list
        self.update_mineral_list()
        
        # Select first mineral if available
        if self.filtered_minerals:
            self.mineral_listbox.selection_set(0)
            self.on_mineral_select()
        
    def create_search_panel(self):
        """Create the search and filter panel."""
        # Search section
        search_frame = ttk.LabelFrame(self.left_panel, text="Search & Filters", padding=10)
        search_frame.pack(fill=tk.X, pady=(0, 10))
        
        # Search entry
        ttk.Label(search_frame, text="Search Minerals:").pack(anchor=tk.W)
        self.search_var = tk.StringVar()
        self.search_var.trace('w', self.on_search_change)
        search_entry = ttk.Entry(search_frame, textvariable=self.search_var)
        search_entry.pack(fill=tk.X, pady=(2, 10))
        
        # Element filter
        ttk.Label(search_frame, text="Contains Elements:").pack(anchor=tk.W)
        self.elements_var = tk.StringVar()
        self.elements_var.trace('w', self.on_filter_change)
        elements_entry = ttk.Entry(search_frame, textvariable=self.elements_var)
        elements_entry.pack(fill=tk.X, pady=(2, 5))
        ttk.Label(search_frame, text="(e.g., Si, Al, O - comma separated, case-sensitive)", 
                 font=('TkDefaultFont', 8)).pack(anchor=tk.W, pady=(0, 10))
        
        # Crystal system filter
        ttk.Label(search_frame, text="Crystal System:").pack(anchor=tk.W)
        self.crystal_system_var = tk.StringVar()
        self.crystal_system_var.trace('w', self.on_filter_change)
        
        crystal_systems = ["All", "Cubic", "Tetragonal", "Orthorhombic", 
                          "Hexagonal", "Trigonal", "Monoclinic", "Triclinic"]
        self.crystal_combo = ttk.Combobox(search_frame, textvariable=self.crystal_system_var,
                                         values=crystal_systems, state="readonly")
        self.crystal_combo.set("All")
        self.crystal_combo.pack(fill=tk.X, pady=(2, 10))
        
        # Hey classification filter
        ttk.Label(search_frame, text="Hey Classification:").pack(anchor=tk.W)
        self.hey_class_var = tk.StringVar()
        self.hey_class_var.trace('w', self.on_filter_change)
        
        # Load Hey classifications and populate dropdown
        hey_classes = ["All"] + self.hey_manager.get_all_classifications()
        self.hey_combo = ttk.Combobox(search_frame, textvariable=self.hey_class_var,
                                     values=hey_classes, state="readonly")
        self.hey_combo.set("All")
        self.hey_combo.pack(fill=tk.X, pady=(2, 10))
        
        # Clear filters button
        ttk.Button(search_frame, text="Clear All Filters", 
                  command=self.clear_filters).pack(fill=tk.X, pady=5)
        
        # Mineral list section
        list_frame = ttk.LabelFrame(self.left_panel, text="Minerals", padding=10)
        list_frame.pack(fill=tk.BOTH, expand=True)
        
        # Mineral count label
        self.count_label = ttk.Label(list_frame, text="0 minerals found")
        self.count_label.pack(anchor=tk.W, pady=(0, 5))
        
        # Mineral listbox with scrollbar
        listbox_frame = ttk.Frame(list_frame)
        listbox_frame.pack(fill=tk.BOTH, expand=True)
        
        self.mineral_listbox = tk.Listbox(listbox_frame, selectmode=tk.BROWSE)
        self.mineral_listbox.pack(fill=tk.BOTH, expand=True, side=tk.LEFT)
        self.mineral_listbox.bind('<<ListboxSelect>>', self.on_mineral_select)
        
        # Scrollbar for listbox
        list_scrollbar = ttk.Scrollbar(listbox_frame, orient=tk.VERTICAL, 
                                      command=self.mineral_listbox.yview)
        list_scrollbar.pack(side=tk.RIGHT, fill=tk.Y)
        self.mineral_listbox.configure(yscrollcommand=list_scrollbar.set)
        
        # Database controls
        controls_frame = ttk.LabelFrame(self.left_panel, text="Database Controls", padding=10)
        controls_frame.pack(fill=tk.X, pady=(10, 0))
        
        ttk.Button(controls_frame, text="Add Mineral", 
                  command=self.add_mineral).pack(fill=tk.X, pady=2)
        ttk.Button(controls_frame, text="Delete Selected", 
                  command=self.delete_mineral).pack(fill=tk.X, pady=2)
        ttk.Button(controls_frame, text="Import from Peak Fitting", 
                  command=self.import_from_peak_fitting).pack(fill=tk.X, pady=2)
        ttk.Button(controls_frame, text="Save Database", 
                  command=self.save_database).pack(fill=tk.X, pady=2)
        
    def create_details_panel(self):
        """Create the details and visualization panel."""
        # Create notebook for tabbed interface
        self.notebook = ttk.Notebook(self.right_panel)
        self.notebook.pack(fill=tk.BOTH, expand=True)
        
        # Overview tab
        self.overview_tab = ttk.Frame(self.notebook)
        self.notebook.add(self.overview_tab, text="Overview")
        
        # Spectrum tab
        self.spectrum_tab = ttk.Frame(self.notebook)
        self.notebook.add(self.spectrum_tab, text="Raman Spectrum")
        
        # Modes tab
        self.modes_tab = ttk.Frame(self.notebook)
        self.notebook.add(self.modes_tab, text="Raman Modes")
        
        # Advanced tab
        self.advanced_tab = ttk.Frame(self.notebook)
        self.notebook.add(self.advanced_tab, text="Advanced Properties")
        
        # Create content for each tab
        self.create_overview_tab()
        self.create_spectrum_tab()
        self.create_modes_tab()
        self.create_advanced_tab()
        
    def create_overview_tab(self):
        """Create the overview tab with mineral information."""
        # Mineral header
        header_frame = ttk.Frame(self.overview_tab, padding=10)
        header_frame.pack(fill=tk.X)
        
        self.mineral_title = ttk.Label(header_frame, text="Select a mineral", 
                                      style='Heading.TLabel', font=('TkDefaultFont', 14, 'bold'))
        self.mineral_title.pack(anchor=tk.W)
        
        self.mineral_formula = ttk.Label(header_frame, text="", 
                                        font=('TkDefaultFont', 10, 'italic'))
        self.mineral_formula.pack(anchor=tk.W, pady=(2, 0))
        
        # Basic information
        info_frame = ttk.LabelFrame(self.overview_tab, text="Basic Information", padding=10)
        info_frame.pack(fill=tk.X, padx=10, pady=5)
        
        # Create grid for information
        info_grid = ttk.Frame(info_frame)
        info_grid.pack(fill=tk.X)
        
        # Configure grid columns
        for i in range(4):
            info_grid.columnconfigure(i, weight=1)
        
        # Row 1
        ttk.Label(info_grid, text="Crystal System:").grid(row=0, column=0, sticky=tk.W, padx=5, pady=3)
        self.crystal_system_label = ttk.Label(info_grid, text="", relief="solid", borderwidth=1, 
                                             background="white", width=15)
        self.crystal_system_label.grid(row=0, column=1, sticky=tk.W+tk.E, padx=5, pady=3)
        
        ttk.Label(info_grid, text="Point Group:").grid(row=0, column=2, sticky=tk.W, padx=5, pady=3)
        self.point_group_label = ttk.Label(info_grid, text="", relief="solid", borderwidth=1, 
                                          background="white", width=15)
        self.point_group_label.grid(row=0, column=3, sticky=tk.W+tk.E, padx=5, pady=3)
        
        # Row 2
        ttk.Label(info_grid, text="Space Group:").grid(row=1, column=0, sticky=tk.W, padx=5, pady=3)
        self.space_group_label = ttk.Label(info_grid, text="", relief="solid", borderwidth=1, 
                                          background="white", width=15)
        self.space_group_label.grid(row=1, column=1, sticky=tk.W+tk.E, padx=5, pady=3)
        
        ttk.Label(info_grid, text="Hey Classification:").grid(row=1, column=2, sticky=tk.W, padx=5, pady=3)
        self.hey_class_label = ttk.Label(info_grid, text="", relief="solid", borderwidth=1, 
                                        background="white", width=15)
        self.hey_class_label.grid(row=1, column=3, sticky=tk.W+tk.E, padx=5, pady=3)
        
        # Data availability section
        data_frame = ttk.LabelFrame(self.overview_tab, text="Available Data", padding=10)
        data_frame.pack(fill=tk.X, padx=10, pady=5)
        
        data_grid = ttk.Frame(data_frame)
        data_grid.pack(fill=tk.X)
        
        ttk.Label(data_grid, text="Raman Modes:").grid(row=0, column=0, sticky=tk.W, padx=5, pady=3)
        self.raman_count_label = ttk.Label(data_grid, text="0", relief="solid", borderwidth=1, 
                                          background="white", width=10)
        self.raman_count_label.grid(row=0, column=1, sticky=tk.W, padx=5, pady=3)
        
        ttk.Label(data_grid, text="Phonon Modes:").grid(row=0, column=2, sticky=tk.W, padx=5, pady=3)
        self.phonon_count_label = ttk.Label(data_grid, text="0", relief="solid", borderwidth=1, 
                                           background="white", width=10)
        self.phonon_count_label.grid(row=0, column=3, sticky=tk.W, padx=5, pady=3)
        
        ttk.Label(data_grid, text="Other Data:").grid(row=1, column=0, sticky=tk.W, padx=5, pady=3)
        self.other_data_label = ttk.Label(data_grid, text="", relief="solid", borderwidth=1, 
                                         background="white", width=30)
        self.other_data_label.grid(row=1, column=1, columnspan=3, sticky=tk.W+tk.E, padx=5, pady=3)
        
        # Key features section
        features_frame = ttk.LabelFrame(self.overview_tab, text="Key Spectral Features", padding=10)
        features_frame.pack(fill=tk.BOTH, expand=True, padx=10, pady=5)
        
        self.features_text = tk.Text(features_frame, height=6, wrap=tk.WORD)
        self.features_text.pack(fill=tk.BOTH, expand=True, side=tk.LEFT)
        
        features_scrollbar = ttk.Scrollbar(features_frame, orient=tk.VERTICAL, 
                                          command=self.features_text.yview)
        features_scrollbar.pack(side=tk.RIGHT, fill=tk.Y)
        self.features_text.configure(yscrollcommand=features_scrollbar.set)
        
        # Action buttons
        button_frame = ttk.Frame(self.overview_tab, padding=10)
        button_frame.pack(fill=tk.X)
        
        ttk.Button(button_frame, text="Edit Mineral Info", 
                  command=self.edit_mineral_entry).pack(side=tk.LEFT, padx=5)
        ttk.Button(button_frame, text="Show Detailed Info", 
                  command=self.show_info_popup_for_selected).pack(side=tk.LEFT, padx=5)
        ttk.Button(button_frame, text="Add Example Modes", 
                  command=self.add_example_modes).pack(side=tk.LEFT, padx=5)
        
    def create_spectrum_tab(self):
        """Create the spectrum visualization tab."""
        # Plot controls
        controls_frame = ttk.LabelFrame(self.spectrum_tab, text="Plot Controls", padding=10)
        controls_frame.pack(fill=tk.X, padx=10, pady=5)
        
        control_grid = ttk.Frame(controls_frame)
        control_grid.pack(fill=tk.X)
        
        # X-range controls
        ttk.Label(control_grid, text="X-Range:").grid(row=0, column=0, sticky=tk.W, padx=5)
        self.x_min_var = tk.StringVar(value="50")
        ttk.Entry(control_grid, textvariable=self.x_min_var, width=8).grid(row=0, column=1, padx=2)
        ttk.Label(control_grid, text="to").grid(row=0, column=2, padx=2)
        self.x_max_var = tk.StringVar(value="1500")
        ttk.Entry(control_grid, textvariable=self.x_max_var, width=8).grid(row=0, column=3, padx=2)
        ttk.Label(control_grid, text="cm⁻¹").grid(row=0, column=4, sticky=tk.W, padx=2)
        
        # Peak width control
        ttk.Label(control_grid, text="Peak Width:").grid(row=0, column=5, sticky=tk.W, padx=(20, 5))
        self.peak_width_var = tk.StringVar(value="5")
        ttk.Entry(control_grid, textvariable=self.peak_width_var, width=6).grid(row=0, column=6, padx=2)
        
        # Display options
        ttk.Label(control_grid, text="Options:").grid(row=0, column=7, sticky=tk.W, padx=(20, 5))
        self.show_grid_var = tk.BooleanVar(value=True)
        ttk.Checkbutton(control_grid, text="Grid", variable=self.show_grid_var, 
                       command=self.update_current_plot).grid(row=0, column=8, padx=5)
        
        self.show_peak_labels_var = tk.BooleanVar(value=True)
        ttk.Checkbutton(control_grid, text="Peak Labels", variable=self.show_peak_labels_var,
                       command=self.update_current_plot).grid(row=0, column=9, padx=5)
        
        # Update button
        ttk.Button(control_grid, text="Update Plot", 
                  command=self.update_current_plot).grid(row=0, column=10, padx=(20, 5))
        
        # Matplotlib figure
        viz_frame = ttk.LabelFrame(self.spectrum_tab, text="Raman Spectrum", padding=5)
        viz_frame.pack(fill=tk.BOTH, expand=True, padx=10, pady=5)
        
        # Create figure with better styling
        plt.style.use('seaborn-v0_8-whitegrid')
        self.fig = plt.figure(figsize=(10, 6), dpi=100, facecolor='#f8f8f8', constrained_layout=True)
        self.ax = self.fig.add_subplot(111)
        
        self.canvas = FigureCanvasTkAgg(self.fig, master=viz_frame)
        self.canvas.draw()
        self.canvas.get_tk_widget().pack(fill=tk.BOTH, expand=True)
        
        # Navigation toolbar
        toolbar_frame = ttk.Frame(viz_frame)
        toolbar_frame.pack(fill=tk.X)
        
        try:
            self.toolbar = NavigationToolbar2Tk(self.canvas, toolbar_frame)
        except TypeError:
            # Compatibility fallback for older matplotlib versions
            class CompatNavToolbar(NavigationToolbar2Tk):
                def __init__(self, canvas, parent):
                    self.canvas = canvas
                    self.window = parent
                    NavigationToolbar2Tk.__init__(self, canvas, parent)
            self.toolbar = CompatNavToolbar(self.canvas, toolbar_frame)
        
        self.toolbar.update()
        
    def create_modes_tab(self):
        """Create the Raman modes tab."""
        # Mode controls
        controls_frame = ttk.LabelFrame(self.modes_tab, text="Mode Management", padding=10)
        controls_frame.pack(fill=tk.X, padx=10, pady=5)
        
        ttk.Button(controls_frame, text="Add Mode", 
                  command=self.add_mode).pack(side=tk.LEFT, padx=5)
        ttk.Button(controls_frame, text="Edit Selected", 
                  command=self.edit_mode).pack(side=tk.LEFT, padx=5)
        ttk.Button(controls_frame, text="Delete Selected", 
                  command=self.delete_mode).pack(side=tk.LEFT, padx=5)
        ttk.Button(controls_frame, text="Add Multiple Modes", 
                  command=lambda: self.add_multiple_modes(self.current_mineral) if self.current_mineral else None).pack(side=tk.LEFT, padx=5)
        
        # Modes table
        table_frame = ttk.LabelFrame(self.modes_tab, text="Raman Modes", padding=10)
        table_frame.pack(fill=tk.BOTH, expand=True, padx=10, pady=5)
        
        # Create treeview for modes
        columns = ("position", "symmetry", "intensity")
        self.modes_tree = ttk.Treeview(table_frame, columns=columns, show='headings', height=15)
        
        # Configure columns
        self.modes_tree.heading("position", text="Position (cm⁻¹)")
        self.modes_tree.heading("symmetry", text="Symmetry")
        self.modes_tree.heading("intensity", text="Relative Intensity")
        
        self.modes_tree.column("position", width=150, anchor=tk.CENTER)
        self.modes_tree.column("symmetry", width=150, anchor=tk.CENTER)
        self.modes_tree.column("intensity", width=150, anchor=tk.CENTER)
        
        # Add scrollbars
        tree_frame = ttk.Frame(table_frame)
        tree_frame.pack(fill=tk.BOTH, expand=True)
        
        self.modes_tree.pack(fill=tk.BOTH, expand=True, side=tk.LEFT)
        
        modes_v_scrollbar = ttk.Scrollbar(tree_frame, orient=tk.VERTICAL, 
                                         command=self.modes_tree.yview)
        modes_v_scrollbar.pack(side=tk.RIGHT, fill=tk.Y)
        self.modes_tree.configure(yscrollcommand=modes_v_scrollbar.set)
        
        modes_h_scrollbar = ttk.Scrollbar(tree_frame, orient=tk.HORIZONTAL, 
                                         command=self.modes_tree.xview)
        modes_h_scrollbar.pack(side=tk.BOTTOM, fill=tk.X)
        self.modes_tree.configure(xscrollcommand=modes_h_scrollbar.set)
        
        tree_frame.pack(fill=tk.BOTH, expand=True)
        
    def create_advanced_tab(self):
        """Create the advanced properties tab."""
        # Advanced data controls
        controls_frame = ttk.LabelFrame(self.advanced_tab, text="Advanced Properties", padding=10)
        controls_frame.pack(fill=tk.X, padx=10, pady=5)
        
        # First row of buttons
        button_row1 = ttk.Frame(controls_frame)
        button_row1.pack(fill=tk.X, pady=2)
        
        ttk.Button(button_row1, text="View Dielectric Tensor", 
                  command=self.view_dielectric_tensor).pack(side=tk.LEFT, padx=5)
        ttk.Button(button_row1, text="View Refractive Index", 
                  command=self.view_refractive_index).pack(side=tk.LEFT, padx=5)
        ttk.Button(button_row1, text="View Born Charges", 
                  command=self.view_born_charges).pack(side=tk.LEFT, padx=5)
        ttk.Button(button_row1, text="View Phonon Modes", 
                  command=self.view_phonon_modes).pack(side=tk.LEFT, padx=5)
        
        # Second row of buttons
        button_row2 = ttk.Frame(controls_frame)
        button_row2.pack(fill=tk.X, pady=2)
        
        ttk.Button(button_row2, text="Debug Mineral Data", 
                  command=self.debug_mineral_data).pack(side=tk.LEFT, padx=5)
        ttk.Button(button_row2, text="Convert Phonon to Raman", 
                  command=self.batch_convert_phonon_to_raman).pack(side=tk.LEFT, padx=5)
        ttk.Button(button_row2, text="Update Eigenvectors", 
                  command=self.update_eigenvectors).pack(side=tk.LEFT, padx=5)
        ttk.Button(button_row2, text="Hey Classification Manager", 
                  command=self.open_hey_classification_manager).pack(side=tk.LEFT, padx=5)
        
        # Advanced data display
        data_frame = ttk.LabelFrame(self.advanced_tab, text="Advanced Data Summary", padding=10)
        data_frame.pack(fill=tk.BOTH, expand=True, padx=10, pady=5)
        
        self.advanced_text = tk.Text(data_frame, wrap=tk.WORD)
        self.advanced_text.pack(fill=tk.BOTH, expand=True, side=tk.LEFT)
        
        advanced_scrollbar = ttk.Scrollbar(data_frame, orient=tk.VERTICAL, 
                                          command=self.advanced_text.yview)
        advanced_scrollbar.pack(side=tk.RIGHT, fill=tk.Y)
        self.advanced_text.configure(yscrollcommand=advanced_scrollbar.set)
        
    def on_search_change(self, *args):
        """Handle search text changes."""
        if hasattr(self, '_gui_initialized') and self._gui_initialized:
            self.update_mineral_list()
        
    def on_filter_change(self, *args):
        """Handle filter changes."""
        if hasattr(self, '_gui_initialized') and self._gui_initialized:
            self.update_mineral_list()
        
    def clear_filters(self):
        """Clear all search filters."""
        self.search_var.set("")
        self.elements_var.set("")
        self.crystal_system_var.set("All")
        self.hey_class_var.set("All")
        self.update_mineral_list()
        
    def load_hey_classification_data(self):
        """Load Hey classification data from CSV file."""
        hey_classes = ["All"]
        
        # Look for the Hey classification CSV file
        csv_paths = [
            "RRUFF_Export_with_Hey_Classification.csv",
            os.path.join(os.path.dirname(__file__), "RRUFF_Export_with_Hey_Classification.csv"),
            os.path.join(os.path.expanduser("~"), "RRUFF_Export_with_Hey_Classification.csv"),
            os.path.join(os.path.dirname(__file__), "Hey_class", "RRUFF_Export_20250503_222156_Hey_Celestian.csv"),
            os.path.join(os.path.dirname(__file__), "Hey_class", "hey_improved_classification.csv"),
            "RRUFF_Hey_Index.csv"
        ]
        
        for csv_path in csv_paths:
            if os.path.exists(csv_path):
                try:
                    df = pd.read_csv(csv_path)
                    # Check for different possible column names
                    hey_col = None
                    for col in ['Hey_Classification', 'Hey-Celestian Group Name', 'Hey Classification']:
                        if col in df.columns:
                            hey_col = col
                            break
                    
                    if hey_col:
                        # Get unique classifications, excluding empty/null values
                        unique_classes = df[hey_col].dropna().unique()
                        unique_classes = [cls for cls in unique_classes if cls and str(cls).strip()]
                        hey_classes.extend(sorted(unique_classes))
                        print(f"Loaded {len(unique_classes)} Hey classifications from {csv_path}")
                        break
                except Exception as e:
                    print(f"Error loading Hey classification from {csv_path}: {e}")
                    continue
        
        if len(hey_classes) == 1:  # Only "All" was added
            print("No Hey classification data found. Filter will be disabled.")
            
        return hey_classes
        
    def get_mineral_hey_classification(self, mineral_name):
        """Get Hey classification for a mineral from CSV data."""
        csv_paths = [
            "RRUFF_Export_with_Hey_Classification.csv",
            os.path.join(os.path.dirname(__file__), "RRUFF_Export_with_Hey_Classification.csv"),
            os.path.join(os.path.expanduser("~"), "RRUFF_Export_with_Hey_Classification.csv"),
            os.path.join(os.path.dirname(__file__), "Hey_class", "RRUFF_Export_20250503_222156_Hey_Celestian.csv"),
            os.path.join(os.path.dirname(__file__), "Hey_class", "hey_improved_classification.csv"),
            "RRUFF_Hey_Index.csv"
        ]
        
        for csv_path in csv_paths:
            if os.path.exists(csv_path):
                try:
                    df = pd.read_csv(csv_path)
                    # Check for different possible column names
                    name_col = None
                    hey_col = None
                    
                    for col in ['Mineral_Name', 'Mineral Name', 'mineral_name']:
                        if col in df.columns:
                            name_col = col
                            break
                    
                    for col in ['Hey_Classification', 'Hey-Celestian Group Name', 'Hey Classification']:
                        if col in df.columns:
                            hey_col = col
                            break
                    
                    if name_col and hey_col:
                        # Try exact match first
                        match = df[df[name_col].str.upper() == mineral_name.upper()]
                        if not match.empty:
                            classification = match.iloc[0][hey_col]
                            if pd.notna(classification) and str(classification).strip():
                                return str(classification).strip()
                        
                        # Try partial match
                        match = df[df[name_col].str.upper().str.contains(mineral_name.upper(), na=False)]
                        if not match.empty:
                            classification = match.iloc[0][hey_col]
                            if pd.notna(classification) and str(classification).strip():
                                return str(classification).strip()
                except Exception as e:
                    continue
                    
        return None
        
    def _extract_elements_from_formula(self, formula):
        """
        Extract element symbols from a chemical formula.
        
        This method properly parses chemical formulas to extract individual element symbols,
        distinguishing between single-letter elements (C, O, N) and multi-letter elements (Ca, Cl, Cr).
        
        Parameters:
        -----------
        formula : str
            Chemical formula (e.g., "CaCO3", "SiO2", "Al2O3")
            
        Returns:
        --------
        set
            Set of element symbols found in the formula
        """
        import re
        
        if not formula or not isinstance(formula, str):
            return set()
        
        # Remove common non-element characters and normalize
        clean_formula = re.sub(r'[0-9\(\)\[\]\{\}\.\s\-\+]', '', formula)
        
        # Regular expression to match element symbols
        # Element symbols start with uppercase letter, optionally followed by lowercase letter(s)
        element_pattern = r'[A-Z][a-z]*'
        
        # Find all element symbols
        elements = re.findall(element_pattern, clean_formula)
        
        # Filter out invalid "elements" that are too long (likely not real elements)
        valid_elements = set()
        for element in elements:
            # Most element symbols are 1-2 characters, a few are 3 (like synthetic elements)
            if len(element) <= 3:
                valid_elements.add(element)
        
        return valid_elements
        
    def _extract_tensor_matrix(self, tensor_data):
        """
        Extract a 3x3 tensor matrix from various data formats.
        
        Parameters:
        -----------
        tensor_data : various
            Tensor data in various formats (dict, list, DataFrame, etc.)
            
        Returns:
        --------
        list or None
            3x3 matrix as list of lists, or None if extraction fails
        """
        if tensor_data is None:
            return None
            
        # Initialize 3x3 matrix with zeros
        matrix = [[0.0 for _ in range(3)] for _ in range(3)]
        
        try:
            if isinstance(tensor_data, dict):
                # Special handling for complex tensor data format
                if 'tensor' in tensor_data and isinstance(tensor_data['tensor'], list):
                    result = self._parse_complex_tensor_format(tensor_data['tensor'])
                    if result is not None:
                        return result
                
                # Try different possible keys for tensor data
                for key in ['tensor', 'EigenV', 'dielectric_tensor', 'matrix', 'values']:
                    if key in tensor_data:
                        candidate = tensor_data[key]
                        result = self._parse_matrix_data(candidate)
                        if result is not None:
                            return result
                
                # If no specific key found, try to parse the dict directly
                result = self._parse_matrix_data(tensor_data)
                if result is not None:
                    return result
                    
            elif isinstance(tensor_data, (list, tuple)):
                result = self._parse_matrix_data(tensor_data)
                if result is not None:
                    return result
                    
            elif hasattr(tensor_data, 'values'):  # DataFrame or similar
                result = self._parse_matrix_data(tensor_data.values)
                if result is not None:
                    return result
                    
        except Exception as e:
            print(f"Error extracting tensor matrix: {e}")
            
        return None
        
    def _parse_matrix_data(self, data):
        """
        Parse matrix data from various formats into a 3x3 matrix.
        
        Parameters:
        -----------
        data : various
            Matrix data in various formats
            
        Returns:
        --------
        list or None
            3x3 matrix as list of lists, or None if parsing fails
        """
        if data is None:
            return None
            
        try:
            # Convert to numpy array for easier handling
            import numpy as np
            
            if isinstance(data, (list, tuple)):
                # Check if it's a flattened matrix first
                if len(data) == 9 and all(isinstance(x, (int, float)) for x in data):
                    # Flattened 3x3 matrix
                    matrix = []
                    for i in range(3):
                        row = []
                        for j in range(3):
                            try:
                                row.append(float(data[i*3 + j]))
                            except (ValueError, TypeError, IndexError):
                                row.append(0.0)
                        matrix.append(row)
                    return matrix
                    
                # Handle nested lists/tuples
                elif len(data) >= 3 and any(isinstance(x, (list, tuple)) for x in data):
                    matrix = []
                    for i in range(3):
                        row = []
                        if i < len(data):
                            row_data = data[i]
                            if isinstance(row_data, (list, tuple)) and len(row_data) >= 3:
                                # Standard 3x3 matrix format
                                for j in range(3):
                                    try:
                                        row.append(float(row_data[j]))
                                    except (ValueError, TypeError, IndexError):
                                        row.append(0.0)
                            else:
                                # Fill with zeros if can't parse
                                row = [0.0, 0.0, 0.0]
                        else:
                            row = [0.0, 0.0, 0.0]
                        matrix.append(row)
                    return matrix
                    
                # Handle diagonal values (3 elements, all numbers)
                elif len(data) == 3 and all(isinstance(x, (int, float)) for x in data):
                    matrix = []
                    for i in range(3):
                        row = []
                        for j in range(3):
                            if i == j:
                                try:
                                    row.append(float(data[i]))
                                except (ValueError, TypeError):
                                    row.append(0.0)
                            else:
                                row.append(0.0)
                        matrix.append(row)
                    return matrix
                    
                # Try to interpret as some form of matrix data
                elif len(data) >= 6 and all(isinstance(x, (int, float)) for x in data):
                    matrix = [[0.0 for _ in range(3)] for _ in range(3)]
                    for i, val in enumerate(data[:9]):
                        try:
                            row = i // 3
                            col = i % 3
                            if row < 3 and col < 3:
                                matrix[row][col] = float(val)
                        except (ValueError, TypeError):
                            pass
                    return matrix
                    
            elif hasattr(data, 'shape'):  # numpy array or similar
                arr = np.array(data)
                if arr.shape == (3, 3):
                    return arr.tolist()
                elif arr.shape == (9,):
                    return arr.reshape(3, 3).tolist()
                elif arr.size >= 9:
                    return arr.flatten()[:9].reshape(3, 3).tolist()
                    
            elif isinstance(data, dict):
                # Try to extract from dictionary with component names
                matrix = [[0.0 for _ in range(3)] for _ in range(3)]
                components = ['xx', 'xy', 'xz', 'yx', 'yy', 'yz', 'zx', 'zy', 'zz']
                indices = [(0,0), (0,1), (0,2), (1,0), (1,1), (1,2), (2,0), (2,1), (2,2)]
                
                for comp, (i, j) in zip(components, indices):
                    if comp in data:
                        try:
                            matrix[i][j] = float(data[comp])
                        except (ValueError, TypeError):
                            pass
                            
                # Check if we got any non-zero values
                if any(any(row) for row in matrix):
                    return matrix
                    
        except Exception as e:
            print(f"Error parsing matrix data: {e}")
            
        return None
        
    def _parse_complex_tensor_format(self, tensor_list):
        """
        Parse complex tensor format where data is stored as:
        [["ε∞", "xx", 2.449, 0.0, 0.0], ["ε∞", "yy", 0.0, 2.2795, 0.0], ...]
        
        Parameters:
        -----------
        tensor_list : list
            List of tensor data rows
            
        Returns:
        --------
        list or None
            3x3 matrix as list of lists, or None if parsing fails
        """
        if not isinstance(tensor_list, list) or len(tensor_list) == 0:
            return None
            
        try:
            # Initialize 3x3 matrix with zeros
            matrix = [[0.0 for _ in range(3)] for _ in range(3)]
            
            # Look for ε∞ (dielectric tensor) entries
            epsilon_infinity_symbol = "ε∞"
            # Also check for unicode variants
            unicode_variants = ["\u0190\u221e", "ε∞", "Ɛ∞", "E∞"]
            
            for row in tensor_list:
                if isinstance(row, list) and len(row) >= 3:
                    # Check if this row represents dielectric tensor data
                    tensor_type = str(row[0]) if len(row) > 0 else ""
                    component = str(row[1]) if len(row) > 1 else ""
                    
                    # Check if this is a dielectric tensor row
                    is_dielectric = any(variant in tensor_type for variant in unicode_variants)
                    
                    if is_dielectric and component in ['xx', 'yy', 'zz']:
                        # Extract the diagonal value
                        try:
                            if component == 'xx':
                                # Value should be in position 2 for xx
                                if len(row) > 2:
                                    matrix[0][0] = float(row[2])
                            elif component == 'yy':
                                # Value should be in position 3 for yy  
                                if len(row) > 3:
                                    matrix[1][1] = float(row[3])
                            elif component == 'zz':
                                # Value should be in position 4 for zz
                                if len(row) > 4:
                                    matrix[2][2] = float(row[4])
                        except (ValueError, TypeError, IndexError):
                            # If we can't parse the value, skip this component
                            continue
            
            # Check if we got any non-zero diagonal values
            if matrix[0][0] != 0.0 or matrix[1][1] != 0.0 or matrix[2][2] != 0.0:
                return matrix
                
        except Exception as e:
            print(f"Error parsing complex tensor format: {e}")
            
        return None
        
    def _parse_refractive_index_format(self, tensor_list):
        """
        Parse refractive index data from complex tensor format where data is stored as:
        [["Refractive index (N)", "xx", 1.5649, 0.0, 0.0], ["Refractive index (N)", "yy", 0.0, 1.5098, 0.0], ...]
        
        Parameters:
        -----------
        tensor_list : list
            List of tensor data rows
            
        Returns:
        --------
        list or None
            3x3 matrix as list of lists, or None if parsing fails
        """
        if not isinstance(tensor_list, list) or len(tensor_list) == 0:
            return None
            
        try:
            # Initialize 3x3 matrix with zeros
            matrix = [[0.0 for _ in range(3)] for _ in range(3)]
            
            # Look for refractive index entries
            refractive_index_keywords = ["Refractive index (N)", "Refractive index", "N", "n"]
            
            for row in tensor_list:
                if isinstance(row, list) and len(row) >= 3:
                    # Check if this row represents refractive index data
                    tensor_type = str(row[0]) if len(row) > 0 else ""
                    component = str(row[1]) if len(row) > 1 else ""
                    
                    # Check if this is a refractive index row
                    is_refractive = any(keyword in tensor_type for keyword in refractive_index_keywords)
                    
                    if is_refractive and component in ['xx', 'yy', 'zz']:
                        # Extract the diagonal value
                        try:
                            if component == 'xx':
                                # Value should be in position 2 for xx
                                if len(row) > 2:
                                    matrix[0][0] = float(row[2])
                            elif component == 'yy':
                                # Value should be in position 3 for yy  
                                if len(row) > 3:
                                    matrix[1][1] = float(row[3])
                            elif component == 'zz':
                                # Value should be in position 4 for zz
                                if len(row) > 4:
                                    matrix[2][2] = float(row[4])
                        except (ValueError, TypeError, IndexError):
                            # If we can't parse the value, skip this component
                            continue
            
            # Check if we got any non-zero diagonal values
            if matrix[0][0] != 0.0 or matrix[1][1] != 0.0 or matrix[2][2] != 0.0:
                return matrix
                
        except Exception as e:
            print(f"Error parsing refractive index format: {e}")
            
        return None
        
    def _extract_refractive_index_matrix(self, tensor_data):
        """
        Extract a 3x3 refractive index matrix from various data formats.
        
        Parameters:
        -----------
        tensor_data : various
            Tensor data in various formats (dict, list, DataFrame, etc.)
            
        Returns:
        --------
        list or None
            3x3 matrix as list of lists, or None if extraction fails
        """
        if tensor_data is None:
            return None
            
        try:
            if isinstance(tensor_data, dict):
                # Special handling for complex tensor data format
                if 'tensor' in tensor_data and isinstance(tensor_data['tensor'], list):
                    result = self._parse_refractive_index_format(tensor_data['tensor'])
                    if result is not None:
                        return result
                
                # Try different possible keys for refractive index data
                for key in ['refractive_index', 'n_matrix', 'N', 'n', 'tensor']:
                    if key in tensor_data:
                        candidate = tensor_data[key]
                        result = self._parse_matrix_data(candidate)
                        if result is not None:
                            return result
                
                # If no specific key found, try to parse the dict directly
                result = self._parse_matrix_data(tensor_data)
                if result is not None:
                    return result
                    
            elif isinstance(tensor_data, (list, tuple)):
                # First try refractive index format parsing
                result = self._parse_refractive_index_format(tensor_data)
                if result is not None:
                    return result
                    
                # Then try general matrix parsing
                result = self._parse_matrix_data(tensor_data)
                if result is not None:
                    return result
                    
            elif hasattr(tensor_data, 'values'):  # DataFrame or similar
                result = self._parse_matrix_data(tensor_data.values)
                if result is not None:
                    return result
                    
        except Exception as e:
            print(f"Error extracting refractive index matrix: {e}")
            
        return None
        
    def update_mineral_list(self):
        """Update the mineral list based on current filters."""
        # Safety check - ensure GUI components exist
        if not hasattr(self, 'mineral_listbox') or not hasattr(self, 'count_label'):
            return
            
        # Get all minerals
        all_minerals = self.db.get_minerals()
        
        # Apply filters
        filtered = []
        search_term = self.search_var.get().lower()
        elements_filter = self.elements_var.get().strip()
        crystal_filter = self.crystal_system_var.get()
        hey_filter = self.hey_class_var.get() if hasattr(self, 'hey_class_var') else "All"
        
        for mineral in all_minerals:
            # Skip special entries
            if mineral.startswith('__'):
                continue
                
            # Apply search filter
            if search_term and search_term not in mineral.lower():
                continue
                    
            # Apply elements filter
            if elements_filter:
                mineral_data = self.db.get_mineral_data(mineral)
                if mineral_data and isinstance(mineral_data, dict):
                    formula = mineral_data.get('chemical_formula', '')
                    if isinstance(formula, str) and formula:
                        # Parse elements from the filter (comma-separated)
                        requested_elements = [e.strip() for e in elements_filter.split(',') if e.strip()]
                        
                        # Extract elements from the chemical formula
                        formula_elements = self._extract_elements_from_formula(formula)
                        
                        # Check if all requested elements are in the formula (case-sensitive)
                        elements_found = True
                        for element in requested_elements:
                            if element not in formula_elements:
                                elements_found = False
                                break
                        
                        if not elements_found:
                            continue
                    else:
                        # If no formula available, skip this mineral when filtering by elements
                        continue
                            
            # Apply crystal system filter
            if crystal_filter != "All":
                mineral_data = self.db.get_mineral_data(mineral)
                if mineral_data and isinstance(mineral_data, dict):
                    crystal_system = mineral_data.get('crystal_system', '')
                    if crystal_filter.lower() not in crystal_system.lower():
                        continue
                        
            # Apply Hey classification filter
            if hey_filter != "All":
                hey_class = self.hey_manager.get_classification(mineral)
                if not hey_class or hey_filter not in hey_class:
                    continue
                        
            filtered.append(mineral)
        
        # Update the listbox
        self.filtered_minerals = sorted(filtered)
        self.mineral_listbox.delete(0, tk.END)
        for mineral in self.filtered_minerals:
            self.mineral_listbox.insert(tk.END, mineral)
            
        # Update count label
        self.count_label.config(text=f"{len(self.filtered_minerals)} minerals found")
        
        # Clear selection if no minerals
        if not self.filtered_minerals:
            self.current_mineral = None
            self.update_mineral_display()
            
    def on_mineral_select(self, event=None):
        """Handle mineral selection."""
        if not self.mineral_listbox.curselection():
            return
            
        index = self.mineral_listbox.curselection()[0]
        mineral_name = self.mineral_listbox.get(index)
        self.current_mineral = mineral_name
        self.update_mineral_display()
        
    def update_mineral_display(self):
        """Update all displays for the current mineral."""
        # Safety check - ensure GUI components exist
        if not hasattr(self, 'mineral_title'):
            return
            
        if not self.current_mineral:
            # Clear all displays
            self.mineral_title.config(text="Select a mineral")
            self.mineral_formula.config(text="")
            self.crystal_system_label.config(text="")
            self.point_group_label.config(text="")
            self.space_group_label.config(text="")
            self.hey_class_label.config(text="")
            self.raman_count_label.config(text="0")
            self.phonon_count_label.config(text="0")
            self.other_data_label.config(text="")
            self.features_text.delete(1.0, tk.END)
            self.advanced_text.delete(1.0, tk.END)
            self.update_modes_table("")
            self.update_current_plot()
            return
            
        mineral_data = self.db.get_mineral_data(self.current_mineral)
        if not mineral_data or not isinstance(mineral_data, dict):
            return
            
        # Update overview tab
        self.mineral_title.config(text=self.current_mineral)
        
        formula = mineral_data.get('chemical_formula', '')
        self.mineral_formula.config(text=f"Formula: {formula}" if formula else "")
        
        self.crystal_system_label.config(text=mineral_data.get('crystal_system', ''))
        self.point_group_label.config(text=mineral_data.get('point_group', ''))
        self.space_group_label.config(text=mineral_data.get('space_group', ''))
        
        # Get and display Hey classification
        hey_class = self.hey_manager.get_classification(self.current_mineral)
        self.hey_class_label.config(text=hey_class if hey_class else '')
        
        # Count data
        modes = self.db.get_modes(self.current_mineral)
        raman_count = len(modes) if isinstance(modes, list) else 0
        self.raman_count_label.config(text=str(raman_count))
        
        phonon_modes = mineral_data.get('phonon_modes', None)
        phonon_count = len(phonon_modes) if isinstance(phonon_modes, pd.DataFrame) and not phonon_modes.empty else 0
        self.phonon_count_label.config(text=str(phonon_count))
        
        # Other data
        other_data = []
        for key in ['dielectric_tensor', 'born_charges']:
            if key in mineral_data and mineral_data[key] is not None:
                other_data.append(key.replace('_', ' ').title())
        self.other_data_label.config(text=", ".join(other_data) if other_data else "None")
        
        # Key features
        self.features_text.delete(1.0, tk.END)
        if raman_count > 0:
            sorted_modes = sorted(modes, key=lambda x: x[2], reverse=True)
            top_modes = sorted_modes[:5]
            features = f"Strong Raman peaks at: {', '.join([f'{pos:.0f}' for pos, _, _ in top_modes])} cm⁻¹\n\n"
                
            if formula:
                features += f"Chemical Formula: {formula}\n\n"
                
            features += f"Total Raman modes: {raman_count}\n"
            if phonon_count > 0:
                features += f"Phonon modes available: {phonon_count}\n"
                
        else:
            features = "No Raman modes available for this mineral.\n\n"
            features += "Consider adding example modes or importing from other sources."
            
        self.features_text.insert(1.0, features)
        
        # Update advanced tab
        self.update_advanced_display()
        
        # Update modes table
        self.update_modes_table(self.current_mineral)
        
        # Update plot
        self.update_current_plot()
        
    def update_advanced_display(self):
        """Update the advanced properties display."""
        self.advanced_text.delete(1.0, tk.END)
        
        if not self.current_mineral:
            return
            
        mineral_data = self.db.get_mineral_data(self.current_mineral)
        if not mineral_data or not isinstance(mineral_data, dict):
            return
            
        text = f"Advanced Properties for {self.current_mineral}\n"
        text += "=" * 50 + "\n\n"
        
        # Dielectric tensor
        if 'dielectric_tensor' in mineral_data and mineral_data['dielectric_tensor'] is not None:
            text += "Dielectric Tensor: Available\n"
        else:
            text += "Dielectric Tensor: Not available\n"
            
        # Born charges
        if 'born_charges' in mineral_data and mineral_data['born_charges'] is not None:
            text += "Born Charges: Available\n"
        else:
            text += "Born Charges: Not available\n"
            
        # Phonon modes
        phonon_modes = mineral_data.get('phonon_modes', None)
        if isinstance(phonon_modes, pd.DataFrame) and not phonon_modes.empty:
            text += f"Phonon Modes: {len(phonon_modes)} modes available\n"
            text += f"Columns: {', '.join(phonon_modes.columns)}\n"
        else:
            text += "Phonon Modes: Not available\n"
            
        # Other properties
        text += "\nOther Properties:\n"
        for key, value in mineral_data.items():
            if key not in ['name', 'crystal_system', 'point_group', 'space_group', 
                          'modes', 'dielectric_tensor', 'born_charges', 'phonon_modes',
                          'chemical_formula']:
                text += f"  {key}: {type(value).__name__}\n"
                
        self.advanced_text.insert(1.0, text)

    def update_current_plot(self):
        """Update the current plot with the selected mineral's spectrum."""
        if not hasattr(self, 'ax') or not hasattr(self, 'canvas'):
            return
             
        self.ax.clear()
         
        if not self.current_mineral:
            self.ax.set_title("No mineral selected")
            self.ax.set_xlabel("Wavenumber (cm⁻¹)")
            self.ax.set_ylabel("Intensity (a.u.)")
            self.canvas.draw()
            return
             
        # Get modes for the current mineral
        modes = self.db.get_modes(self.current_mineral)
        if not modes or len(modes) == 0:
            self.ax.set_title(f"{self.current_mineral} - No Raman modes available")
            self.ax.set_xlabel("Wavenumber (cm⁻¹)")
            self.ax.set_ylabel("Intensity (a.u.)")
            self.canvas.draw()
            return
             
        # Get plot parameters
        try:
            x_min = float(self.x_min_var.get())
            x_max = float(self.x_max_var.get())
            peak_width = float(self.peak_width_var.get())
        except (ValueError, AttributeError):
            x_min, x_max, peak_width = 50, 1500, 5
             
        # Create synthetic spectrum from modes
        x = np.linspace(x_min, x_max, 1000)
        y = np.zeros_like(x)
         
        # Add Gaussian peaks for each mode
        for position, symmetry, intensity in modes:
            if x_min <= position <= x_max:
                # Create Gaussian peak
                peak = intensity * np.exp(-0.5 * ((x - position) / peak_width) ** 2)
                y += peak
                 
        # Plot the spectrum
        self.ax.plot(x, y, 'b-', linewidth=2, label=self.current_mineral)
         
        # Add peak labels if enabled
        if hasattr(self, 'show_peak_labels_var') and self.show_peak_labels_var.get():
            for position, symmetry, intensity in modes:
                if x_min <= position <= x_max and intensity > 0.3:  # Only label strong peaks
                    self.ax.annotate(f'{position:.0f}\n{symmetry}', 
                                   xy=(position, intensity), 
                                   xytext=(position, intensity + 0.1),
                                   ha='center', va='bottom', fontsize=8,
                                   arrowprops=dict(arrowstyle='->', color='red', lw=0.5))
         
        # Set plot properties
        self.ax.set_xlabel("Wavenumber (cm⁻¹)")
        self.ax.set_ylabel("Relative Intensity")
        self.ax.set_title(f"Raman Spectrum - {self.current_mineral}")
        self.ax.set_xlim(x_min, x_max)
         
        # Grid
        if hasattr(self, 'show_grid_var') and self.show_grid_var.get():
            self.ax.grid(True, alpha=0.3)
             
        # Legend
        self.ax.legend()
         
        # Draw the plot
        self.canvas.draw()
         
    def update_modes_table(self, mineral_name):
        """Update the modes table for the selected mineral."""
        if not hasattr(self, 'modes_tree'):
            return
             
        # Clear the tree
        self.modes_tree.delete(*self.modes_tree.get_children())
         
        if not mineral_name:
            return
             
        # Get the modes
        modes = self.db.get_modes(mineral_name)
        if not modes:
            return
             
        # Add modes to the tree
        for mode in modes:
            try:
                position, symmetry, intensity = mode
                self.modes_tree.insert('', tk.END, values=(f"{position:.2f}", symmetry, f"{intensity:.3f}"))
            except Exception as e:
                print(f"Error adding mode to table: {e}")
                continue
                 
    def add_mineral(self):
        """Add a new mineral to the database."""
        name = tk.simpledialog.askstring("Add Mineral", "Enter mineral name:")
        if not name:
            return
             
        crystal_system = tk.simpledialog.askstring("Crystal System", "Enter crystal system (optional):")
        point_group = tk.simpledialog.askstring("Point Group", "Enter point group (optional):")
        space_group = tk.simpledialog.askstring("Space Group", "Enter space group (optional):")
         
        success = self.db.add_mineral(name, crystal_system, point_group, space_group)
        if success:
            self.update_mineral_list()
            messagebox.showinfo("Success", f"Mineral '{name}' added successfully.")
        else:
            messagebox.showerror("Error", f"Mineral '{name}' already exists.")
             
    def delete_mineral(self):
        """Delete the selected mineral from the database."""
        if not self.current_mineral:
            messagebox.showwarning("Warning", "No mineral selected.")
            return
             
        confirm = messagebox.askyesno("Confirm Deletion", 
                                    f"Are you sure you want to delete '{self.current_mineral}'?")
        if confirm:
            success = self.db.delete_mineral(self.current_mineral)
            if success:
                self.update_mineral_list()
                self.current_mineral = None
                self.update_mineral_display()
                messagebox.showinfo("Success", "Mineral deleted successfully.")
            else:
                messagebox.showerror("Error", "Failed to delete mineral.")
                 
    def add_mode(self):
        """Add a new Raman mode to the selected mineral."""
        if not self.current_mineral:
            messagebox.showwarning("Warning", "No mineral selected.")
            return
             
        # Get mode details
        position = tk.simpledialog.askfloat("Peak Position", "Enter peak position (cm⁻¹):")
        if position is None:
            return
             
        symmetry = tk.simpledialog.askstring("Symmetry", "Enter symmetry character:")
        if not symmetry:
            return
             
        intensity = tk.simpledialog.askfloat("Intensity", "Enter relative intensity (default: 1.0):", initialvalue=1.0)
        if intensity is None:
            intensity = 1.0
             
        # Add mode
        success = self.db.add_mode(self.current_mineral, position, symmetry, intensity)
        if success:
            self.update_modes_table(self.current_mineral)
            self.update_current_plot()
            self.update_mineral_display()
            messagebox.showinfo("Success", f"Raman mode added to '{self.current_mineral}'.")
             
    def edit_mode(self):
        """Edit an existing Raman mode."""
        if not self.current_mineral:
            messagebox.showwarning("Warning", "No mineral selected.")
            return
             
        selection = self.modes_tree.selection()
        if not selection:
            messagebox.showwarning("Warning", "No mode selected.")
            return
             
        # Get mode index
        mode_index = self.modes_tree.index(selection[0])
         
        # Get current values
        modes = self.db.get_modes(self.current_mineral)
        if mode_index >= len(modes):
            return
             
        current_position, current_symmetry, current_intensity = modes[mode_index]
         
        # Get new values
        position = tk.simpledialog.askfloat("Peak Position", "Enter peak position (cm⁻¹):", 
                                           initialvalue=current_position)
        if position is None:
            return
             
        symmetry = tk.simpledialog.askstring("Symmetry", "Enter symmetry character:", 
                                            initialvalue=current_symmetry)
        if not symmetry:
            return
             
        intensity = tk.simpledialog.askfloat("Intensity", "Enter relative intensity:", 
                                            initialvalue=current_intensity)
        if intensity is None:
            return
             
        # Update mode
        modes[mode_index] = (position, symmetry, intensity)
         
        # Update display
        self.update_modes_table(self.current_mineral)
        self.update_current_plot()
        self.update_mineral_display()
         
    def delete_mode(self):
        """Delete a Raman mode from the selected mineral."""
        if not self.current_mineral:
            messagebox.showwarning("Warning", "No mineral selected.")
            return
             
        selection = self.modes_tree.selection()
        if not selection:
            messagebox.showwarning("Warning", "No mode selected.")
            return
             
        # Get mode index
        mode_index = self.modes_tree.index(selection[0])
         
        # Confirm deletion
        confirm = messagebox.askyesno("Confirm", "Are you sure you want to delete this mode?")
        if not confirm:
            return
             
        # Delete mode
        modes = self.db.get_modes(self.current_mineral)
        if mode_index < len(modes):
            del modes[mode_index]
             
            # Update display
            self.update_modes_table(self.current_mineral)
            self.update_current_plot()
            self.update_mineral_display()
             
    def save_database(self):
        """Save the database to file."""
        success = self.db.save_database()
         
        if success:
            messagebox.showinfo("Save Successful", "Database saved successfully.")
        else:
            messagebox.showerror("Save Failed", "Failed to save database.")
             
    def show_info_popup_for_selected(self):
        """Show info popup for the currently selected mineral."""
        if not self.current_mineral:
            messagebox.showwarning("Warning", "No mineral selected.")
            return
             
        mineral_data = self.db.get_mineral_data(self.current_mineral)
         
        if not mineral_data:
            messagebox.showwarning("Warning", f"No data found for {self.current_mineral}.")
            return
             
        self.show_info_popup(self.current_mineral, mineral_data)
         
    def show_info_popup(self, mineral_name, mineral_data):
        """Show mineral information in a detailed popup window."""
        try:
            # Create popup window
            popup = tk.Toplevel(self.window)
            popup.title(f"Detailed Information: {mineral_name}")
            popup.geometry("600x500")
            popup.transient(self.window)
             
            # Create notebook for organized display
            notebook = ttk.Notebook(popup, padding=10)
            notebook.pack(fill=tk.BOTH, expand=True)
             
            # Basic info tab
            basic_tab = ttk.Frame(notebook)
            notebook.add(basic_tab, text="Basic Information")
             
            basic_text = tk.Text(basic_tab, wrap=tk.WORD)
            basic_text.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)
             
            # Insert basic information
            info = f"Mineral Name: {mineral_name}\n\n"
             
            formula = mineral_data.get('chemical_formula', '')
            if formula:
                info += f"Chemical Formula: {formula}\n\n"
                 
            info += f"Crystal System: {mineral_data.get('crystal_system', 'Not specified')}\n"
            info += f"Point Group: {mineral_data.get('point_group', 'Not specified')}\n"
            info += f"Space Group: {mineral_data.get('space_group', 'Not specified')}\n\n"
             

                 
            basic_text.insert(tk.END, info)
            basic_text.config(state=tk.DISABLED)
             
            # Raman modes tab
            modes_tab = ttk.Frame(notebook)
            notebook.add(modes_tab, text="Raman Modes")
             
            modes_text = tk.Text(modes_tab, wrap=tk.WORD)
            modes_text.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)
             
            modes = self.db.get_modes(mineral_name)
            if modes:
                modes_info = f"Raman Modes ({len(modes)} total):\n\n"
                modes_info += "Position (cm⁻¹)    Symmetry    Intensity\n"
                modes_info += "-" * 40 + "\n"
                 
                for pos, sym, intensity in sorted(modes, key=lambda x: x[0]):
                    modes_info += f"{pos:>8.1f}         {sym:<10}  {intensity:.3f}\n"
            else:
                modes_info = "No Raman modes available for this mineral."
                 
            modes_text.insert(tk.END, modes_info)
            modes_text.config(state=tk.DISABLED)
             
            # Advanced data tab
            advanced_tab = ttk.Frame(notebook)
            notebook.add(advanced_tab, text="Advanced Data")
             
            advanced_text = tk.Text(advanced_tab, wrap=tk.WORD)
            advanced_text.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)
             
            advanced_info = "Advanced Properties:\n\n"
             
            # Check for phonon modes
            phonon_modes = mineral_data.get('phonon_modes', None)
            if isinstance(phonon_modes, pd.DataFrame) and not phonon_modes.empty:
                advanced_info += f"Phonon Modes: {len(phonon_modes)} modes available\n"
                advanced_info += f"Columns: {', '.join(phonon_modes.columns)}\n\n"
                 
            # Check for other advanced properties
            for key in ['dielectric_tensor', 'born_charges']:
                if key in mineral_data and mineral_data[key] is not None:
                    advanced_info += f"{key.replace('_', ' ').title()}: Available\n"
                     
            # List other properties
            other_props = []
            for key, value in mineral_data.items():
                if key not in ['name', 'crystal_system', 'point_group', 'space_group', 
                              'modes', 'dielectric_tensor', 'born_charges', 'phonon_modes',
                              'chemical_formula']:
                    other_props.append(f"{key}: {type(value).__name__}")
                     
            if other_props:
                advanced_info += "\nOther Properties:\n"
                for prop in other_props:
                    advanced_info += f"  {prop}\n"
                     
            advanced_text.insert(tk.END, advanced_info)
            advanced_text.config(state=tk.DISABLED)
             
            # Add close button
            ttk.Button(popup, text="Close", command=popup.destroy).pack(pady=10)
             
        except Exception as e:
            print(f"Error in show_info_popup: {e}")
            messagebox.showerror("Error", f"Could not display mineral information: {e}")
             
    def run(self):
        """Run the GUI application."""
        # Only call mainloop if we're running in standalone mode
        if hasattr(self, 'is_standalone') and self.is_standalone:
            # Update the mineral list before showing the window
            self.update_mineral_list()
            # Start the mainloop
            self.window.mainloop()
        else:
            # For embedded mode, just update the mineral list and return
            # The parent application's mainloop will handle the window
            self.update_mineral_list()
             
    # Keep the existing methods that are still needed
    def select_random_mineral(self):
        """Select a random mineral from the list."""
        if self.filtered_minerals:
            import random
            random_mineral = random.choice(self.filtered_minerals)
            try:
                index = self.filtered_minerals.index(random_mineral)
                self.mineral_listbox.selection_clear(0, tk.END)
                self.mineral_listbox.selection_set(index)
                self.mineral_listbox.see(index)
                self.on_mineral_select()
            except ValueError:
                pass
                 
    def add_example_modes_for_mineral(self, mineral_name):
        """Add example modes for a mineral that has no modes defined."""
        print(f"Adding example modes for {mineral_name}")
         
        # Create some example modes based on mineral name characteristics
        modes = []
         
        # Check if mineral name contains common elements to create somewhat realistic modes
        name_upper = mineral_name.upper()
         
        if "QUARTZ" in name_upper or "SIO2" in name_upper:
            # Quartz-like modes
            modes = [
                (128.0, "A1", 0.5),
                (206.0, "E", 0.7),
                (464.0, "A1", 1.0),
                (696.0, "E", 0.2),
                (796.0, "E", 0.3),
                (1085.0, "A1", 0.5)
            ]
        elif "CALCITE" in name_upper or "ARAGONITE" in name_upper or "CACO3" in name_upper:
            # Carbonate modes
            modes = [
                (154.0, "Eg", 0.3),
                (281.0, "Eg", 0.4),
                (712.0, "A1g", 1.0),
                (1087.0, "A1g", 0.8)
            ]
        elif "TITANIUM" in name_upper or "ANATASE" in name_upper or "TIO2" in name_upper:
            # Titanium oxide modes
            modes = [
                (144.0, "Eg", 1.0),
                (197.0, "Eg", 0.2),
                (399.0, "B1g", 0.3),
                (513.0, "A1g", 0.4),
                (639.0, "Eg", 0.5)
            ]
        else:
            # Generic random peaks for any other mineral type
            import random
            # Generate 3-7 random modes
            num_modes = random.randint(3, 7)
            symmetries = ["A1g", "A2g", "B1g", "B2g", "Eg"]
             
            for _ in range(num_modes):
                position = random.uniform(100, 1200)  # Random position between 100-1200 cm-1
                symmetry = random.choice(symmetries)
                intensity = random.uniform(0.3, 1.0)
                modes.append((position, symmetry, intensity))
                 
            # Sort by position
            modes.sort(key=lambda x: x[0])
         
        # Add the modes to the database
        if modes:
            print(f"Adding {len(modes)} example modes to {mineral_name}")
            mineral_data = self.db.get_mineral_data(mineral_name)
            if mineral_data:
                mineral_data['modes'] = modes
                print(f"Example modes added successfully")
                return True
            else:
                print(f"Failed to add example modes - mineral data not found")
         
        return False

    def edit_mineral_entry(self):
        """Open a dialog to edit all parameters of the selected mineral."""
        if not self.current_mineral:
            messagebox.showwarning("Warning", "No mineral selected.")
            return
             
        # Get current mineral data
        mineral_data = self.db.get_mineral_data(self.current_mineral)
        if not mineral_data or not isinstance(mineral_data, dict):
            messagebox.showwarning("Warning", f"Cannot edit {self.current_mineral}. Invalid data format.")
            return
         
        # Create a new dialog window
        dialog = tk.Toplevel(self.window)
        dialog.title(f"Edit Mineral Entry - {self.current_mineral}")
        dialog.geometry("600x400")
        dialog.transient(self.window)
        dialog.grab_set()  # Make dialog modal
         
        # Main frame
        main_frame = ttk.Frame(dialog, padding=10)
        main_frame.pack(fill=tk.BOTH, expand=True)
         
        # Basic Info section
        info_frame = ttk.LabelFrame(main_frame, text="Basic Information", padding=10)
        info_frame.pack(fill=tk.X, pady=5)
         
        # Name field (display only, can't change the key)
        ttk.Label(info_frame, text="Mineral Name:").grid(row=0, column=0, sticky=tk.W, padx=5, pady=5)
        name_var = tk.StringVar(value=self.current_mineral)
        ttk.Entry(info_frame, textvariable=name_var, state='readonly', width=30).grid(row=0, column=1, sticky=tk.W+tk.E, padx=5, pady=5)
         
        # Chemical formula
        ttk.Label(info_frame, text="Chemical Formula:").grid(row=1, column=0, sticky=tk.W, padx=5, pady=5)
        formula_var = tk.StringVar(value=mineral_data.get('chemical_formula', ''))
        ttk.Entry(info_frame, textvariable=formula_var, width=30).grid(row=1, column=1, sticky=tk.W+tk.E, padx=5, pady=5)
         
        # Crystal System
        ttk.Label(info_frame, text="Crystal System:").grid(row=2, column=0, sticky=tk.W, padx=5, pady=5)
        crystal_system_var = tk.StringVar(value=mineral_data.get('crystal_system', ''))
        crystal_systems = ['', 'Cubic', 'Hexagonal', 'Trigonal', 'Tetragonal', 'Orthorhombic', 'Monoclinic', 'Triclinic']
        ttk.Combobox(info_frame, textvariable=crystal_system_var, values=crystal_systems, width=28).grid(row=2, column=1, sticky=tk.W+tk.E, padx=5, pady=5)
         
        # Point Group
        ttk.Label(info_frame, text="Point Group:").grid(row=3, column=0, sticky=tk.W, padx=5, pady=5)
        point_group_var = tk.StringVar(value=mineral_data.get('point_group', ''))
        ttk.Entry(info_frame, textvariable=point_group_var, width=30).grid(row=3, column=1, sticky=tk.W+tk.E, padx=5, pady=5)
         
        # Space Group
        ttk.Label(info_frame, text="Space Group:").grid(row=4, column=0, sticky=tk.W, padx=5, pady=5)
        space_group_var = tk.StringVar(value=mineral_data.get('space_group', ''))
        ttk.Entry(info_frame, textvariable=space_group_var, width=30).grid(row=4, column=1, sticky=tk.W+tk.E, padx=5, pady=5)
         
        # Configure column weights
        info_frame.columnconfigure(1, weight=1)
         
        # Save function
        def save_changes():
            try:
                # Update the mineral data
                mineral_data['chemical_formula'] = formula_var.get()
                mineral_data['crystal_system'] = crystal_system_var.get()
                mineral_data['point_group'] = point_group_var.get()
                mineral_data['space_group'] = space_group_var.get()
                 
                # Save the database
                self.db.save_database()
                 
                # Update the display
                self.update_mineral_display()
                 
                # Close the dialog
                dialog.destroy()
                 
                # Show success message
                messagebox.showinfo("Success", f"Mineral '{self.current_mineral}' updated successfully.")
                 
            except Exception as e:
                messagebox.showerror("Error", f"Failed to save changes: {str(e)}")
         
        # Button frame
        button_frame = ttk.Frame(main_frame)
        button_frame.pack(fill=tk.X, pady=10)
         
        ttk.Button(button_frame, text="Save Changes", command=save_changes).pack(side=tk.RIGHT, padx=5)
        ttk.Button(button_frame, text="Cancel", command=dialog.destroy).pack(side=tk.RIGHT, padx=5)
         
    def import_from_peak_fitting(self):
        """Import data from peak_fitting.py output."""
        # This would typically involve getting data from peak_fitting.py results
        # For now, we'll use a placeholder asking for mineral name and data
        mineral_name = tk.simpledialog.askstring("Import from Peak Fitting", 
                                                "Enter mineral name:")
        if not mineral_name:
            return
         
        messagebox.showinfo("Import from Peak Fitting", 
                          "This would normally import data directly from peak_fitting.py results.\n\n"
                          "For this demo, please use 'Add Mode' to add peaks manually.")
                           
    def add_multiple_modes(self, mineral_name):
        """Add multiple Raman modes at once to a mineral."""
        if not mineral_name:
            return
             
        # Create a new dialog window
        dialog = tk.Toplevel(self.window)
        dialog.title(f"Add Multiple Modes - {mineral_name}")
        dialog.geometry("600x400")
        dialog.transient(self.window)
        dialog.grab_set()
         
        # Create a frame for the table
        frame = ttk.Frame(dialog, padding=10)
        frame.pack(fill=tk.BOTH, expand=True)
         
        # Instructions
        ttk.Label(frame, text="Enter multiple Raman modes (position, symmetry, intensity):").pack(pady=(0, 10))
         
        # Create a table for entering multiple modes
        # Headers
        headers_frame = ttk.Frame(frame)
        headers_frame.pack(fill=tk.X)
         
        ttk.Label(headers_frame, text="Position (cm⁻¹)", width=15).grid(row=0, column=0, padx=5, pady=5)
        ttk.Label(headers_frame, text="Symmetry", width=15).grid(row=0, column=1, padx=5, pady=5)
        ttk.Label(headers_frame, text="Intensity", width=15).grid(row=0, column=2, padx=5, pady=5)
         
        # Create a canvas with scrollbar for the entries
        canvas_frame = ttk.Frame(frame)
        canvas_frame.pack(fill=tk.BOTH, expand=True, pady=5)
         
        canvas = tk.Canvas(canvas_frame)
        scrollbar = ttk.Scrollbar(canvas_frame, orient="vertical", command=canvas.yview)
         
        entries_frame = ttk.Frame(canvas)
        entries_frame.bind("<Configure>", lambda e: canvas.configure(scrollregion=canvas.bbox("all")))
         
        canvas.create_window((0, 0), window=entries_frame, anchor="nw")
        canvas.configure(yscrollcommand=scrollbar.set)
         
        canvas.pack(side="left", fill="both", expand=True)
        scrollbar.pack(side="right", fill="y")
         
        # Entry rows (start with 10 rows)
        mode_entries = []
        for i in range(10):
            row_frame = ttk.Frame(entries_frame)
            row_frame.pack(fill=tk.X, pady=2)
             
            position_var = tk.StringVar()
            symmetry_var = tk.StringVar()
            intensity_var = tk.StringVar(value="1.0")  # Default intensity
             
            position_entry = ttk.Entry(row_frame, textvariable=position_var, width=15)
            position_entry.grid(row=0, column=0, padx=5)
             
            symmetry_entry = ttk.Entry(row_frame, textvariable=symmetry_var, width=15)
            symmetry_entry.grid(row=0, column=1, padx=5)
             
            intensity_entry = ttk.Entry(row_frame, textvariable=intensity_var, width=15)
            intensity_entry.grid(row=0, column=2, padx=5)
             
            mode_entries.append((position_var, symmetry_var, intensity_var))
         
        # Save function
        def save_modes():
            added_count = 0
            error_count = 0
             
            for pos_var, sym_var, int_var in mode_entries:
                # Skip empty rows
                if not pos_var.get() or not sym_var.get():
                    continue
                     
                try:
                    position = float(pos_var.get())
                    symmetry = sym_var.get()
                     
                    # Handle empty or invalid intensity
                    intensity = 1.0
                    if int_var.get():
                        try:
                            intensity = float(int_var.get())
                        except ValueError:
                            pass
                     
                    # Add mode to database
                    success = self.db.add_mode(mineral_name, position, symmetry, intensity)
                    if success:
                        added_count += 1
                    else:
                        error_count += 1
                except ValueError:
                    error_count += 1
             
            # Update the UI
            self.update_modes_table(mineral_name)
            self.update_current_plot()
            self.update_mineral_display()
             
            # Show result message
            if added_count > 0:
                result_msg = f"Successfully added {added_count} modes to '{mineral_name}'."
                if error_count > 0:
                    result_msg += f"\nFailed to add {error_count} modes."
                messagebox.showinfo("Success", result_msg)
            else:
                messagebox.showwarning("Warning", "No modes were added.")
             
            # Close dialog
            dialog.destroy()
         
        # Buttons frame
        buttons_frame = ttk.Frame(frame)
        buttons_frame.pack(fill=tk.X, pady=10)
         
        ttk.Button(buttons_frame, text="Save", command=save_modes).pack(side=tk.RIGHT, padx=5)
        ttk.Button(buttons_frame, text="Cancel", command=dialog.destroy).pack(side=tk.RIGHT, padx=5)
         
    def add_example_modes(self):
        """Add example Raman modes to the selected mineral."""
        if not self.current_mineral:
            messagebox.showwarning("Warning", "No mineral selected.")
            return
             
        # Add example modes for the current mineral
        success = self.add_example_modes_for_mineral(self.current_mineral)
         
        if success:
            # Update the UI
            self.update_modes_table(self.current_mineral)
            self.update_current_plot()
            self.update_mineral_display()
            messagebox.showinfo("Success", f"Added example Raman modes to {self.current_mineral}.")
        else:
            messagebox.showwarning("Warning", "Failed to add example modes.")
             
    def view_dielectric_tensor(self):
        """Display dielectric tensor for the selected mineral."""
        if not self.current_mineral:
            messagebox.showwarning("Warning", "No mineral selected.")
            return
            
        mineral_data = self.db.get_mineral_data(self.current_mineral)
        if not mineral_data or not isinstance(mineral_data, dict):
            messagebox.showwarning("Warning", "No mineral data found.")
            return
            
        # Check if dielectric tensor data exists
        dielectric_data = mineral_data.get('dielectric_tensor', None)
        if not dielectric_data:
            messagebox.showinfo("No Data", f"No dielectric tensor data available for {self.current_mineral}.")
            return
            
        # Create viewer window
        viewer_window = tk.Toplevel(self.window)
        viewer_window.title(f"Dielectric Tensor - {self.current_mineral}")
        viewer_window.geometry("700x600")
        viewer_window.transient(self.window)
        
        # Main frame
        main_frame = ttk.Frame(viewer_window, padding=10)
        main_frame.pack(fill=tk.BOTH, expand=True)
        
        # Title
        title_label = ttk.Label(main_frame, text=f"Dielectric Tensor for {self.current_mineral}", 
                               font=('TkDefaultFont', 12, 'bold'))
        title_label.pack(pady=(0, 10))
        
        # Create notebook for different views
        notebook = ttk.Notebook(main_frame)
        notebook.pack(fill=tk.BOTH, expand=True)
        
        # Matrix view tab
        matrix_tab = ttk.Frame(notebook)
        notebook.add(matrix_tab, text="Tensor Matrix")
        
        # Raw data tab
        raw_tab = ttk.Frame(notebook)
        notebook.add(raw_tab, text="Raw Data")
        
        # Matrix view
        matrix_frame = ttk.LabelFrame(matrix_tab, text="Dielectric Tensor Matrix", padding=10)
        matrix_frame.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)
        
        # Extract tensor matrix with robust parsing
        tensor_matrix = self._extract_tensor_matrix(dielectric_data)
            
        if tensor_matrix is not None:
            # Display as 3x3 matrix
            matrix_display = ttk.Frame(matrix_frame)
            matrix_display.pack(pady=10)
            
            ttk.Label(matrix_display, text="ε∞ Tensor:", font=('TkDefaultFont', 10, 'bold')).grid(row=0, column=0, columnspan=3, pady=(0, 10))
            
            for i in range(3):
                for j in range(3):
                    try:
                        value = f"{float(tensor_matrix[i][j]):.4f}"
                    except (IndexError, ValueError, TypeError):
                        value = "0.0000"
                    
                    entry = tk.Entry(matrix_display, width=12, justify=tk.CENTER)
                    entry.grid(row=i+1, column=j, padx=2, pady=2)
                    entry.insert(0, value)
                    entry.config(state='readonly')
            
            # Add axis labels
            ttk.Label(matrix_display, text="x").grid(row=0, column=0, padx=2)
            ttk.Label(matrix_display, text="y").grid(row=0, column=1, padx=2)
            ttk.Label(matrix_display, text="z").grid(row=0, column=2, padx=2)
            
            # Eigenvalues and eigenvectors if available
            if isinstance(dielectric_data, dict) and 'EigenV' in dielectric_data:
                eigen_frame = ttk.LabelFrame(matrix_tab, text="Eigenvectors", padding=10)
                eigen_frame.pack(fill=tk.X, padx=10, pady=5)
                
                eigen_data = dielectric_data['EigenV']
                if isinstance(eigen_data, list) and len(eigen_data) >= 3:
                    for i, eigenvec in enumerate(eigen_data[:3]):
                        if isinstance(eigenvec, (list, tuple)) and len(eigenvec) >= 3:
                            vec_text = f"Eigenvector {i+1}: [{eigenvec[0]:.4f}, {eigenvec[1]:.4f}, {eigenvec[2]:.4f}]"
                            ttk.Label(eigen_frame, text=vec_text).pack(anchor=tk.W, pady=2)
        else:
            ttk.Label(matrix_frame, text="No valid tensor matrix data found.").pack(pady=20)
        
        # Raw data view
        raw_frame = ttk.Frame(raw_tab, padding=10)
        raw_frame.pack(fill=tk.BOTH, expand=True)
        
        raw_text = tk.Text(raw_frame, wrap=tk.WORD)
        raw_text.pack(fill=tk.BOTH, expand=True, side=tk.LEFT)
        
        raw_scrollbar = ttk.Scrollbar(raw_frame, orient=tk.VERTICAL, command=raw_text.yview)
        raw_scrollbar.pack(side=tk.RIGHT, fill=tk.Y)
        raw_text.configure(yscrollcommand=raw_scrollbar.set)
        
        # Display raw data
        import json
        raw_data_str = json.dumps(dielectric_data, indent=2, default=str)
        raw_text.insert(tk.END, raw_data_str)
        raw_text.config(state=tk.DISABLED)
        
                # Close button
        ttk.Button(main_frame, text="Close", command=viewer_window.destroy).pack(pady=10)
    
    def view_refractive_index(self):
        """Display refractive index matrix for the selected mineral."""
        if not self.current_mineral:
            messagebox.showwarning("Warning", "No mineral selected.")
            return
            
        mineral_data = self.db.get_mineral_data(self.current_mineral)
        if not mineral_data or not isinstance(mineral_data, dict):
            messagebox.showwarning("Warning", "No mineral data found.")
            return
            
        # Check if refractive index data exists - try multiple possible keys
        refractive_data = None
        possible_keys = ['refractive_index', 'dielectric_tensor', 'tensor_data', 'optical_properties']
        
        for key in possible_keys:
            if key in mineral_data and mineral_data[key] is not None:
                refractive_data = mineral_data[key]
                break
        
        if not refractive_data:
            messagebox.showinfo("No Data", f"No refractive index data available for {self.current_mineral}.")
            return
            
        # Create viewer window
        viewer_window = tk.Toplevel(self.window)
        viewer_window.title(f"Refractive Index Matrix - {self.current_mineral}")
        viewer_window.geometry("700x600")
        viewer_window.transient(self.window)
        
        # Main frame
        main_frame = ttk.Frame(viewer_window, padding=10)
        main_frame.pack(fill=tk.BOTH, expand=True)
        
        # Title
        title_label = ttk.Label(main_frame, text=f"Refractive Index Matrix for {self.current_mineral}", 
                               font=('TkDefaultFont', 12, 'bold'))
        title_label.pack(pady=(0, 10))
        
        # Create notebook for different views
        notebook = ttk.Notebook(main_frame)
        notebook.pack(fill=tk.BOTH, expand=True)
        
        # Matrix view tab
        matrix_tab = ttk.Frame(notebook)
        notebook.add(matrix_tab, text="Refractive Index Matrix")
        
        # Raw data tab
        raw_tab = ttk.Frame(notebook)
        notebook.add(raw_tab, text="Raw Data")
        
        # Matrix view
        matrix_frame = ttk.LabelFrame(matrix_tab, text="Refractive Index Matrix", padding=10)
        matrix_frame.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)
        
        # Extract refractive index matrix with robust parsing
        refractive_matrix = self._extract_refractive_index_matrix(refractive_data)
            
        if refractive_matrix is not None:
            # Display as 3x3 matrix
            matrix_display = ttk.Frame(matrix_frame)
            matrix_display.pack(pady=10)
            
            ttk.Label(matrix_display, text="n (Refractive Index):", font=('TkDefaultFont', 10, 'bold')).grid(row=0, column=0, columnspan=3, pady=(0, 10))
            
            for i in range(3):
                for j in range(3):
                    try:
                        value = f"{float(refractive_matrix[i][j]):.4f}"
                    except (IndexError, ValueError, TypeError):
                        value = "0.0000"
                    
                    entry = tk.Entry(matrix_display, width=12, justify=tk.CENTER)
                    entry.grid(row=i+1, column=j, padx=2, pady=2)
                    entry.insert(0, value)
                    entry.config(state='readonly')
            
            # Add axis labels
            ttk.Label(matrix_display, text="x").grid(row=0, column=0, padx=2)
            ttk.Label(matrix_display, text="y").grid(row=0, column=1, padx=2)
            ttk.Label(matrix_display, text="z").grid(row=0, column=2, padx=2)
            
            # Additional information
            info_frame = ttk.LabelFrame(matrix_tab, text="Optical Properties", padding=10)
            info_frame.pack(fill=tk.X, padx=10, pady=5)
            
            # Calculate and display additional optical properties
            try:
                nx = refractive_matrix[0][0]
                ny = refractive_matrix[1][1] 
                nz = refractive_matrix[2][2]
                
                info_text = f"Principal refractive indices:\n"
                info_text += f"  nx = {nx:.4f}\n"
                info_text += f"  ny = {ny:.4f}\n"
                info_text += f"  nz = {nz:.4f}\n\n"
                
                # Calculate birefringence
                if nx > 0 and ny > 0 and nz > 0:
                    max_n = max(nx, ny, nz)
                    min_n = min(nx, ny, nz)
                    birefringence = max_n - min_n
                    info_text += f"Birefringence (Δn): {birefringence:.4f}\n"
                    
                    # Determine optical character
                    if abs(nx - ny) < 0.001 and abs(ny - nz) < 0.001:
                        optical_char = "Isotropic"
                    elif abs(nx - ny) < 0.001:
                        optical_char = "Uniaxial"
                        if nz > nx:
                            optical_char += " positive"
                        else:
                            optical_char += " negative"
                    else:
                        optical_char = "Biaxial"
                        
                    info_text += f"Optical character: {optical_char}\n"
                
                ttk.Label(info_frame, text=info_text, justify=tk.LEFT).pack(anchor=tk.W)
                
            except (ValueError, TypeError, IndexError):
                ttk.Label(info_frame, text="Could not calculate optical properties").pack(anchor=tk.W)
                
        else:
            ttk.Label(matrix_frame, text="No valid refractive index matrix data found.").pack(pady=20)
        
        # Raw data view
        raw_frame = ttk.Frame(raw_tab, padding=10)
        raw_frame.pack(fill=tk.BOTH, expand=True)
        
        raw_text = tk.Text(raw_frame, wrap=tk.WORD)
        raw_text.pack(fill=tk.BOTH, expand=True, side=tk.LEFT)
        
        raw_scrollbar = ttk.Scrollbar(raw_frame, orient=tk.VERTICAL, command=raw_text.yview)
        raw_scrollbar.pack(side=tk.RIGHT, fill=tk.Y)
        raw_text.configure(yscrollcommand=raw_scrollbar.set)
        
        # Display raw data
        import json
        raw_data_str = json.dumps(refractive_data, indent=2, default=str)
        raw_text.insert(tk.END, raw_data_str)
        raw_text.config(state=tk.DISABLED)
        
        # Close button
        ttk.Button(main_frame, text="Close", command=viewer_window.destroy).pack(pady=10)
    
    def view_born_charges(self):
        """Display Born effective charges for the selected mineral."""
        if not self.current_mineral:
            messagebox.showwarning("Warning", "No mineral selected.")
            return
             
        mineral_data = self.db.get_mineral_data(self.current_mineral)
        if not mineral_data or not isinstance(mineral_data, dict):
            messagebox.showwarning("Warning", "No mineral data found.")
            return
            
        # Check if Born charges data exists
        born_charges_data = mineral_data.get('born_charges', None)
        if not born_charges_data:
            messagebox.showinfo("No Data", f"No Born charges data available for {self.current_mineral}.")
            return
            
        # Create viewer window
        viewer_window = tk.Toplevel(self.window)
        viewer_window.title(f"Born Effective Charges - {self.current_mineral}")
        viewer_window.geometry("800x700")
        viewer_window.transient(self.window)
        
        # Main frame
        main_frame = ttk.Frame(viewer_window, padding=10)
        main_frame.pack(fill=tk.BOTH, expand=True)
        
        # Title
        title_label = ttk.Label(main_frame, text=f"Born Effective Charges for {self.current_mineral}", 
                               font=('TkDefaultFont', 12, 'bold'))
        title_label.pack(pady=(0, 10))
        
        # Create notebook for different views
        notebook = ttk.Notebook(main_frame)
        notebook.pack(fill=tk.BOTH, expand=True)
        
        # Charges view tab
        charges_tab = ttk.Frame(notebook)
        notebook.add(charges_tab, text="Born Charges")
        
        # Raw data tab
        raw_tab = ttk.Frame(notebook)
        notebook.add(raw_tab, text="Raw Data")
        
        # Charges view
        charges_frame = ttk.Frame(charges_tab, padding=10)
        charges_frame.pack(fill=tk.BOTH, expand=True)
        
        # Create scrollable frame for charges
        canvas = tk.Canvas(charges_frame)
        scrollbar = ttk.Scrollbar(charges_frame, orient="vertical", command=canvas.yview)
        scrollable_frame = ttk.Frame(canvas)
        
        scrollable_frame.bind(
            "<Configure>",
            lambda e: canvas.configure(scrollregion=canvas.bbox("all"))
        )
        
        canvas.create_window((0, 0), window=scrollable_frame, anchor="nw")
        canvas.configure(yscrollcommand=scrollbar.set)
        
        # Process Born charges data
        if isinstance(born_charges_data, list):
            for i, atom_data in enumerate(born_charges_data):
                if isinstance(atom_data, dict):
                    atom_name = atom_data.get('atom', f'Atom {i+1}')
                    charge_tensor = atom_data.get('charge', None)
                    
                    # Create frame for this atom
                    atom_frame = ttk.LabelFrame(scrollable_frame, text=f"{atom_name}", padding=10)
                    atom_frame.pack(fill=tk.X, padx=5, pady=5)
                    
                    if charge_tensor and isinstance(charge_tensor, list) and len(charge_tensor) >= 3:
                        # Display as 3x3 matrix
                        matrix_frame = ttk.Frame(atom_frame)
                        matrix_frame.pack(pady=5)
                        
                        ttk.Label(matrix_frame, text="Born Charge Tensor:", 
                                 font=('TkDefaultFont', 9, 'bold')).grid(row=0, column=0, columnspan=3, pady=(0, 5))
                        
                        for row in range(3):
                            for col in range(3):
                                try:
                                    if isinstance(charge_tensor[row], (list, tuple)) and len(charge_tensor[row]) > col:
                                        value = f"{float(charge_tensor[row][col]):.4f}"
                                    else:
                                        value = "0.0000"
                                except (IndexError, ValueError, TypeError):
                                    value = "N/A"
                                
                                entry = tk.Entry(matrix_frame, width=10, justify=tk.CENTER)
                                entry.grid(row=row+1, column=col, padx=1, pady=1)
                                entry.insert(0, value)
                                entry.config(state='readonly')
                        
                        # Add axis labels
                        ttk.Label(matrix_frame, text="x", font=('TkDefaultFont', 8)).grid(row=0, column=0)
                        ttk.Label(matrix_frame, text="y", font=('TkDefaultFont', 8)).grid(row=0, column=1)
                        ttk.Label(matrix_frame, text="z", font=('TkDefaultFont', 8)).grid(row=0, column=2)
                        
                        # Eigenvectors if available
                        if 'EigenV' in atom_data:
                            eigen_data = atom_data['EigenV']
                            if isinstance(eigen_data, list) and len(eigen_data) >= 3:
                                eigen_frame = ttk.Frame(atom_frame)
                                eigen_frame.pack(pady=5)
                                ttk.Label(eigen_frame, text="Eigenvectors:", 
                                         font=('TkDefaultFont', 9, 'bold')).pack(anchor=tk.W)
                                for j, eigenvec in enumerate(eigen_data[:3]):
                                    if isinstance(eigenvec, (list, tuple)) and len(eigenvec) >= 3:
                                        vec_text = f"  v{j+1}: [{eigenvec[0]:.4f}, {eigenvec[1]:.4f}, {eigenvec[2]:.4f}]"
                                        ttk.Label(eigen_frame, text=vec_text, font=('TkDefaultFont', 8)).pack(anchor=tk.W)
                    else:
                        ttk.Label(atom_frame, text="No valid charge tensor data").pack(pady=5)
        else:
            ttk.Label(scrollable_frame, text="No valid Born charges data found.").pack(pady=20)
        
        canvas.pack(side="left", fill="both", expand=True)
        scrollbar.pack(side="right", fill="y")
        
        # Raw data view
        raw_frame = ttk.Frame(raw_tab, padding=10)
        raw_frame.pack(fill=tk.BOTH, expand=True)
        
        raw_text = tk.Text(raw_frame, wrap=tk.WORD)
        raw_text.pack(fill=tk.BOTH, expand=True, side=tk.LEFT)
        
        raw_scrollbar = ttk.Scrollbar(raw_frame, orient=tk.VERTICAL, command=raw_text.yview)
        raw_scrollbar.pack(side=tk.RIGHT, fill=tk.Y)
        raw_text.configure(yscrollcommand=raw_scrollbar.set)
        
        # Display raw data
        import json
        raw_data_str = json.dumps(born_charges_data, indent=2, default=str)
        raw_text.insert(tk.END, raw_data_str)
        raw_text.config(state=tk.DISABLED)
        
        # Close button
        ttk.Button(main_frame, text="Close", command=viewer_window.destroy).pack(pady=10)
                           
    def view_phonon_modes(self):
        """Display full phonon mode list for the selected mineral."""
        if not self.current_mineral:
            messagebox.showwarning("Warning", "No mineral selected.")
            return
             
        mineral_data = self.db.get_mineral_data(self.current_mineral)
        if not mineral_data or not isinstance(mineral_data, dict):
            messagebox.showwarning("Warning", "No mineral data found.")
            return
            
        # Check if phonon modes data exists
        phonon_modes_data = mineral_data.get('phonon_modes', None)
        if phonon_modes_data is None or (isinstance(phonon_modes_data, pd.DataFrame) and phonon_modes_data.empty):
            messagebox.showinfo("No Data", f"No phonon modes data available for {self.current_mineral}.")
            return
            
        # Create viewer window
        viewer_window = tk.Toplevel(self.window)
        viewer_window.title(f"Phonon Modes - {self.current_mineral}")
        viewer_window.geometry("1000x700")
        viewer_window.transient(self.window)
        
        # Main frame
        main_frame = ttk.Frame(viewer_window, padding=10)
        main_frame.pack(fill=tk.BOTH, expand=True)
        
        # Title
        title_label = ttk.Label(main_frame, text=f"Phonon Modes for {self.current_mineral}", 
                               font=('TkDefaultFont', 12, 'bold'))
        title_label.pack(pady=(0, 10))
        
        # Create notebook for different views
        notebook = ttk.Notebook(main_frame)
        notebook.pack(fill=tk.BOTH, expand=True)
        
        # Table view tab
        table_tab = ttk.Frame(notebook)
        notebook.add(table_tab, text="Modes Table")
        
        # Summary tab
        summary_tab = ttk.Frame(notebook)
        notebook.add(summary_tab, text="Summary")
        
        # Raw data tab
        raw_tab = ttk.Frame(notebook)
        notebook.add(raw_tab, text="Raw Data")
        
        # Table view
        table_frame = ttk.Frame(table_tab, padding=10)
        table_frame.pack(fill=tk.BOTH, expand=True)
        
        # Convert DataFrame to list of dictionaries if needed
        modes_list = []
        if isinstance(phonon_modes_data, pd.DataFrame):
            modes_list = phonon_modes_data.to_dict('records')
            columns = list(phonon_modes_data.columns)
        elif isinstance(phonon_modes_data, list):
            modes_list = phonon_modes_data
            # Try to determine columns from first item
            if modes_list and isinstance(modes_list[0], dict):
                columns = list(modes_list[0].keys())
            else:
                columns = ['Mode', 'Frequency', 'Activity']
        else:
            columns = ['Property', 'Value']
            modes_list = [{'Property': k, 'Value': v} for k, v in phonon_modes_data.items() if isinstance(phonon_modes_data, dict)]
        
        if modes_list:
            # Create treeview for modes
            tree_frame = ttk.Frame(table_frame)
            tree_frame.pack(fill=tk.BOTH, expand=True)
            
            # Limit columns to most important ones for display
            display_columns = []
            for col in ['Mode', 'Frequency', 'TO_Frequency', 'LO_Frequency', 'Activity', 'I_Total', 'symmetry', 'position']:
                if col in columns:
                    display_columns.append(col)
            
            # If no standard columns found, use first 6 columns
            if not display_columns:
                display_columns = columns[:6]
            
            tree = ttk.Treeview(tree_frame, columns=display_columns, show='headings', height=20)
            
            # Configure columns
            for col in display_columns:
                tree.heading(col, text=col)
                if 'frequency' in col.lower() or 'i_total' in col.lower():
                    tree.column(col, width=100, anchor=tk.CENTER)
                elif col.lower() in ['mode', 'activity', 'symmetry']:
                    tree.column(col, width=120, anchor=tk.W)
                else:
                    tree.column(col, width=80, anchor=tk.CENTER)
            
            # Add data to tree
            for mode in modes_list:
                values = []
                for col in display_columns:
                    value = mode.get(col, '')
                    if isinstance(value, (int, float)):
                        if 'frequency' in col.lower():
                            values.append(f"{value:.2f}")
                        else:
                            values.append(f"{value:.4f}")
                    else:
                        values.append(str(value))
                tree.insert('', tk.END, values=values)
            
            tree.pack(fill=tk.BOTH, expand=True, side=tk.LEFT)
            
            # Add scrollbars
            v_scrollbar = ttk.Scrollbar(tree_frame, orient=tk.VERTICAL, command=tree.yview)
            v_scrollbar.pack(side=tk.RIGHT, fill=tk.Y)
            tree.configure(yscrollcommand=v_scrollbar.set)
            
            h_scrollbar = ttk.Scrollbar(table_frame, orient=tk.HORIZONTAL, command=tree.xview)
            h_scrollbar.pack(side=tk.BOTTOM, fill=tk.X)
            tree.configure(xscrollcommand=h_scrollbar.set)
            
            # Summary view
            summary_frame = ttk.Frame(summary_tab, padding=10)
            summary_frame.pack(fill=tk.BOTH, expand=True)
            
            summary_text = tk.Text(summary_frame, wrap=tk.WORD)
            summary_text.pack(fill=tk.BOTH, expand=True, side=tk.LEFT)
            
            summary_scrollbar = ttk.Scrollbar(summary_frame, orient=tk.VERTICAL, command=summary_text.yview)
            summary_scrollbar.pack(side=tk.RIGHT, fill=tk.Y)
            summary_text.configure(yscrollcommand=summary_scrollbar.set)
            
            # Generate summary
            summary = f"Phonon Modes Summary for {self.current_mineral}\n"
            summary += "=" * 50 + "\n\n"
            summary += f"Total number of modes: {len(modes_list)}\n\n"
            
            # Count activities
            activities = {}
            frequencies = []
            for mode in modes_list:
                activity = mode.get('Activity', mode.get('activity', 'Unknown'))
                activities[activity] = activities.get(activity, 0) + 1
                
                # Collect frequencies
                for freq_key in ['Frequency', 'TO_Frequency', 'frequency']:
                    if freq_key in mode:
                        try:
                            freq = float(mode[freq_key])
                            if freq > 0:
                                frequencies.append(freq)
                                break
                        except (ValueError, TypeError):
                            pass
            
            summary += "Mode Activities:\n"
            for activity, count in activities.items():
                summary += f"  {activity}: {count} modes\n"
            
            if frequencies:
                summary += f"\nFrequency Range: {min(frequencies):.2f} - {max(frequencies):.2f} cm⁻¹\n"
                summary += f"Average Frequency: {sum(frequencies)/len(frequencies):.2f} cm⁻¹\n"
            
            # Show available columns
            summary += f"\nAvailable Data Columns:\n"
            for col in columns:
                summary += f"  • {col}\n"
            
            summary_text.insert(tk.END, summary)
            summary_text.config(state=tk.DISABLED)
        else:
            ttk.Label(table_frame, text="No phonon modes data found.").pack(pady=20)
        
        # Raw data view
        raw_frame = ttk.Frame(raw_tab, padding=10)
        raw_frame.pack(fill=tk.BOTH, expand=True)
        
        raw_text = tk.Text(raw_frame, wrap=tk.WORD)
        raw_text.pack(fill=tk.BOTH, expand=True, side=tk.LEFT)
        
        raw_scrollbar = ttk.Scrollbar(raw_frame, orient=tk.VERTICAL, command=raw_text.yview)
        raw_scrollbar.pack(side=tk.RIGHT, fill=tk.Y)
        raw_text.configure(yscrollcommand=raw_scrollbar.set)
        
        # Display raw data
        import json
        if isinstance(phonon_modes_data, pd.DataFrame):
            raw_data_str = phonon_modes_data.to_string()
        else:
            raw_data_str = json.dumps(phonon_modes_data, indent=2, default=str)
        raw_text.insert(tk.END, raw_data_str)
        raw_text.config(state=tk.DISABLED)
        
        # Close button
        ttk.Button(main_frame, text="Close", command=viewer_window.destroy).pack(pady=10)
                           
    def debug_mineral_data(self):
        """Debug the mineral data in the database."""
        if not self.current_mineral:
            messagebox.showwarning("Warning", "No mineral selected.")
            return
             
        # Get mineral data
        mineral_data = self.db.get_mineral_data(self.current_mineral)
        if not mineral_data:
            messagebox.showwarning("Warning", "No mineral data found.")
            return
             
        # Create a new window for debugging
        debug_window = tk.Toplevel(self.window)
        debug_window.title(f"Debug - {self.current_mineral}")
        debug_window.geometry("600x400")
        debug_window.transient(self.window)
         
        # Create a text widget to display the mineral data
        text_widget = tk.Text(debug_window, wrap=tk.WORD)
        text_widget.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)
         
        # Add scrollbar to text widget
        text_scroll = ttk.Scrollbar(text_widget, orient="vertical", command=text_widget.yview)
        text_scroll.pack(side=tk.RIGHT, fill=tk.Y)
        text_widget.configure(yscrollcommand=text_scroll.set)
         
        # Convert the mineral data to a readable format
        import json
        data_str = json.dumps(mineral_data, indent=4, default=str)
         
        # Insert the data into the text widget
        text_widget.insert(tk.END, data_str)
        text_widget.config(state=tk.DISABLED)
         
        # Add close button
        ttk.Button(debug_window, text="Close", command=debug_window.destroy).pack(pady=10)
         
    def batch_convert_phonon_to_raman(self):
        """Convert phonon modes to Raman modes for all minerals in the database."""
        messagebox.showinfo("Batch Convert", 
                          "Batch phonon to Raman conversion would be implemented here.\n\n"
                          "This would process all minerals in the database and convert their phonon modes to Raman modes.")
                           
    def update_eigenvectors(self):
        """Update eigenvectors from CSV files for all minerals."""
        messagebox.showinfo("Update Eigenvectors", 
                          "Eigenvector update from CSV files would be implemented here.\n\n"
                          "This would read CSV files and update eigenvector data for all minerals.")
                          
    def open_hey_classification_manager(self):
        """Open the Hey Classification Manager window."""
        manager_window = tk.Toplevel(self.window)
        manager_window.title("Hey-Celestian Classification Manager")
        manager_window.geometry("800x600")
        manager_window.transient(self.window)
        
        # Main frame
        main_frame = ttk.Frame(manager_window, padding=10)
        main_frame.pack(fill=tk.BOTH, expand=True)
        
        # Title
        title_label = ttk.Label(main_frame, text="Hey-Celestian Classification System Manager", 
                               font=('TkDefaultFont', 12, 'bold'))
        title_label.pack(pady=(0, 10))
        
        # Create notebook for different management functions
        notebook = ttk.Notebook(main_frame)
        notebook.pack(fill=tk.BOTH, expand=True)
        
        # Statistics tab
        stats_tab = ttk.Frame(notebook)
        notebook.add(stats_tab, text="Statistics")
        
        # Configuration tab
        config_tab = ttk.Frame(notebook)
        notebook.add(config_tab, text="Configuration")
        
        # Manual Classification tab
        manual_tab = ttk.Frame(notebook)
        notebook.add(manual_tab, text="Manual Classification")
        
        # Export/Import tab
        export_tab = ttk.Frame(notebook)
        notebook.add(export_tab, text="Export/Import")
        
        # Create statistics tab
        self.create_hey_stats_tab(stats_tab)
        
        # Create configuration tab
        self.create_hey_config_tab(config_tab)
        
        # Create manual classification tab
        self.create_hey_manual_tab(manual_tab)
        
        # Create export/import tab
        self.create_hey_export_tab(export_tab)
        
        # Close button
        ttk.Button(main_frame, text="Close", command=manager_window.destroy).pack(pady=10)
        
    def create_hey_stats_tab(self, parent):
        """Create the statistics tab for Hey classification."""
        stats_frame = ttk.Frame(parent, padding=10)
        stats_frame.pack(fill=tk.BOTH, expand=True)
        
        # Refresh button
        ttk.Button(stats_frame, text="Refresh Statistics", 
                  command=lambda: self.update_hey_stats(stats_text)).pack(pady=(0, 10))
        
        # Statistics display
        stats_text = tk.Text(stats_frame, wrap=tk.WORD)
        stats_text.pack(fill=tk.BOTH, expand=True, side=tk.LEFT)
        
        stats_scrollbar = ttk.Scrollbar(stats_frame, orient=tk.VERTICAL, command=stats_text.yview)
        stats_scrollbar.pack(side=tk.RIGHT, fill=tk.Y)
        stats_text.configure(yscrollcommand=stats_scrollbar.set)
        
        # Initial load
        self.update_hey_stats(stats_text)
        
    def update_hey_stats(self, text_widget):
        """Update the Hey classification statistics display."""
        text_widget.delete(1.0, tk.END)
        
        try:
            stats = self.hey_manager.get_statistics()
            
            stats_text = "Hey-Celestian Classification Statistics\n"
            stats_text += "=" * 50 + "\n\n"
            
            stats_text += f"Total Minerals with Classifications: {stats['total_minerals']}\n"
            stats_text += f"Total Unique Classifications: {stats['total_classifications']}\n"
            stats_text += f"Data Sources: {', '.join(stats['sources'])}\n\n"
            
            if stats['confidence_stats']['count'] > 0:
                conf = stats['confidence_stats']
                stats_text += f"Confidence Statistics:\n"
                stats_text += f"  Count: {conf['count']}\n"
                stats_text += f"  Range: {conf['min']:.3f} - {conf['max']:.3f}\n"
                stats_text += f"  Average: {conf['avg']:.3f}\n\n"
            
            stats_text += "Classification Distribution:\n"
            for classification, count in sorted(stats['classification_counts'].items(), 
                                              key=lambda x: x[1], reverse=True):
                stats_text += f"  {classification}: {count}\n"
                
            text_widget.insert(tk.END, stats_text)
            
        except Exception as e:
            text_widget.insert(tk.END, f"Error loading statistics: {e}")
            
    def create_hey_config_tab(self, parent):
        """Create the configuration tab for Hey classification."""
        config_frame = ttk.Frame(parent, padding=10)
        config_frame.pack(fill=tk.BOTH, expand=True)
        
        # CSV Sources section
        sources_frame = ttk.LabelFrame(config_frame, text="CSV Data Sources", padding=10)
        sources_frame.pack(fill=tk.X, pady=(0, 10))
        
        # Current sources list
        ttk.Label(sources_frame, text="Current CSV Sources:").pack(anchor=tk.W)
        
        sources_listbox = tk.Listbox(sources_frame, height=6)
        sources_listbox.pack(fill=tk.X, pady=5)
        
        # Populate sources
        for source in self.hey_manager.config['csv_search_paths']:
            sources_listbox.insert(tk.END, source)
            
        # Source management buttons
        source_buttons = ttk.Frame(sources_frame)
        source_buttons.pack(fill=tk.X, pady=5)
        
        ttk.Button(source_buttons, text="Add Source", 
                  command=lambda: self.add_csv_source(sources_listbox)).pack(side=tk.LEFT, padx=5)
        ttk.Button(source_buttons, text="Remove Selected", 
                  command=lambda: self.remove_csv_source(sources_listbox)).pack(side=tk.LEFT, padx=5)
        ttk.Button(source_buttons, text="Reload Data", 
                  command=self.reload_hey_data).pack(side=tk.LEFT, padx=5)
        
        # Configuration options
        options_frame = ttk.LabelFrame(config_frame, text="Options", padding=10)
        options_frame.pack(fill=tk.X, pady=(0, 10))
        
        # Validation enabled
        self.validation_var = tk.BooleanVar(value=self.hey_manager.config['validation_enabled'])
        ttk.Checkbutton(options_frame, text="Enable Validation", 
                       variable=self.validation_var,
                       command=self.update_hey_config).pack(anchor=tk.W, pady=2)
        
        # Auto update
        self.auto_update_var = tk.BooleanVar(value=self.hey_manager.config['auto_update'])
        ttk.Checkbutton(options_frame, text="Auto Update", 
                       variable=self.auto_update_var,
                       command=self.update_hey_config).pack(anchor=tk.W, pady=2)
        
        # Cache timeout
        cache_frame = ttk.Frame(options_frame)
        cache_frame.pack(fill=tk.X, pady=5)
        ttk.Label(cache_frame, text="Cache Timeout (seconds):").pack(side=tk.LEFT)
        self.cache_timeout_var = tk.StringVar(value=str(self.hey_manager.config['cache_timeout']))
        ttk.Entry(cache_frame, textvariable=self.cache_timeout_var, width=10).pack(side=tk.LEFT, padx=5)
        ttk.Button(cache_frame, text="Update", command=self.update_hey_config).pack(side=tk.LEFT, padx=5)
        
    def create_hey_manual_tab(self, parent):
        """Create the manual classification tab."""
        manual_frame = ttk.Frame(parent, padding=10)
        manual_frame.pack(fill=tk.BOTH, expand=True)
        
        # Add classification section
        add_frame = ttk.LabelFrame(manual_frame, text="Add/Update Classification", padding=10)
        add_frame.pack(fill=tk.X, pady=(0, 10))
        
        # Mineral name
        ttk.Label(add_frame, text="Mineral Name:").grid(row=0, column=0, sticky=tk.W, padx=5, pady=5)
        self.manual_mineral_var = tk.StringVar()
        ttk.Entry(add_frame, textvariable=self.manual_mineral_var, width=30).grid(row=0, column=1, padx=5, pady=5)
        
        # Classification
        ttk.Label(add_frame, text="Classification:").grid(row=1, column=0, sticky=tk.W, padx=5, pady=5)
        self.manual_class_var = tk.StringVar()
        class_combo = ttk.Combobox(add_frame, textvariable=self.manual_class_var, width=30)
        class_combo['values'] = self.hey_manager.get_all_classifications()
        class_combo.grid(row=1, column=1, padx=5, pady=5)
        
        # Confidence
        ttk.Label(add_frame, text="Confidence (0-1):").grid(row=2, column=0, sticky=tk.W, padx=5, pady=5)
        self.manual_confidence_var = tk.StringVar()
        ttk.Entry(add_frame, textvariable=self.manual_confidence_var, width=30).grid(row=2, column=1, padx=5, pady=5)
        
        # Reasoning
        ttk.Label(add_frame, text="Reasoning:").grid(row=3, column=0, sticky=tk.W, padx=5, pady=5)
        self.manual_reasoning_var = tk.StringVar()
        ttk.Entry(add_frame, textvariable=self.manual_reasoning_var, width=30).grid(row=3, column=1, padx=5, pady=5)
        
        # Add button
        ttk.Button(add_frame, text="Add/Update Classification", 
                  command=self.add_manual_classification).grid(row=4, column=0, columnspan=2, pady=10)
        
        # Current mineral classification
        current_frame = ttk.LabelFrame(manual_frame, text="Current Mineral Classification", padding=10)
        current_frame.pack(fill=tk.BOTH, expand=True)
        
        ttk.Button(current_frame, text="Load Current Mineral", 
                  command=self.load_current_mineral_classification).pack(pady=5)
        
        self.current_class_text = tk.Text(current_frame, height=10, wrap=tk.WORD)
        self.current_class_text.pack(fill=tk.BOTH, expand=True)
        
    def create_hey_export_tab(self, parent):
        """Create the export/import tab."""
        export_frame = ttk.Frame(parent, padding=10)
        export_frame.pack(fill=tk.BOTH, expand=True)
        
        # Export section
        export_section = ttk.LabelFrame(export_frame, text="Export Classifications", padding=10)
        export_section.pack(fill=tk.X, pady=(0, 10))
        
        ttk.Button(export_section, text="Export to CSV", 
                  command=lambda: self.export_hey_data('csv')).pack(side=tk.LEFT, padx=5)
        ttk.Button(export_section, text="Export to JSON", 
                  command=lambda: self.export_hey_data('json')).pack(side=tk.LEFT, padx=5)
        
        # Import section
        import_section = ttk.LabelFrame(export_frame, text="Import Classifications", padding=10)
        import_section.pack(fill=tk.X, pady=(0, 10))
        
        ttk.Button(import_section, text="Import CSV File", 
                  command=self.import_hey_data).pack(side=tk.LEFT, padx=5)
        ttk.Button(import_section, text="Reload All Sources", 
                  command=self.reload_all_hey_sources).pack(side=tk.LEFT, padx=5)
        
        # Status
        self.hey_status_text = tk.Text(export_frame, height=15, wrap=tk.WORD)
        self.hey_status_text.pack(fill=tk.BOTH, expand=True)
        
    # Helper methods for Hey classification management
    def add_csv_source(self, listbox):
        """Add a new CSV source."""
        file_path = filedialog.askopenfilename(
            title="Select CSV File",
            filetypes=[("CSV files", "*.csv"), ("All files", "*.*")]
        )
        if file_path:
            self.hey_manager.add_csv_source(file_path)
            listbox.insert(tk.END, file_path)
            
    def remove_csv_source(self, listbox):
        """Remove selected CSV source."""
        selection = listbox.curselection()
        if selection:
            source = listbox.get(selection[0])
            self.hey_manager.remove_csv_source(source)
            listbox.delete(selection[0])
            
    def reload_hey_data(self):
        """Reload Hey classification data."""
        self.hey_manager.load_all_data(force_reload=True)
        # Update the dropdown in the main interface
        hey_classes = ["All"] + self.hey_manager.get_all_classifications()
        self.hey_combo['values'] = hey_classes
        messagebox.showinfo("Success", "Hey classification data reloaded successfully!")
        
    def update_hey_config(self):
        """Update Hey classification configuration."""
        self.hey_manager.config['validation_enabled'] = self.validation_var.get()
        self.hey_manager.config['auto_update'] = self.auto_update_var.get()
        try:
            self.hey_manager.config['cache_timeout'] = int(self.cache_timeout_var.get())
        except ValueError:
            pass
        self.hey_manager.save_config()
        
    def add_manual_classification(self):
        """Add a manual classification."""
        mineral = self.manual_mineral_var.get().strip()
        classification = self.manual_class_var.get().strip()
        
        if not mineral or not classification:
            messagebox.showwarning("Warning", "Please enter both mineral name and classification.")
            return
            
        confidence = None
        if self.manual_confidence_var.get().strip():
            try:
                confidence = float(self.manual_confidence_var.get())
            except ValueError:
                messagebox.showwarning("Warning", "Invalid confidence value.")
                return
                
        reasoning = self.manual_reasoning_var.get().strip() or None
        
        # Validate classification
        is_valid, message = self.hey_manager.validate_classification(classification)
        if not is_valid:
            result = messagebox.askyesno("Validation Warning", 
                                       f"{message}\n\nDo you want to add it anyway?")
            if not result:
                return
                
        # Add classification
        self.hey_manager.add_classification(mineral, classification, confidence, reasoning)
        
        # Update dropdown
        hey_classes = ["All"] + self.hey_manager.get_all_classifications()
        self.hey_combo['values'] = hey_classes
        
        # Clear form
        self.manual_mineral_var.set("")
        self.manual_class_var.set("")
        self.manual_confidence_var.set("")
        self.manual_reasoning_var.set("")
        
        messagebox.showinfo("Success", f"Classification added for {mineral}")
        
    def load_current_mineral_classification(self):
        """Load classification for the currently selected mineral."""
        if not self.current_mineral:
            messagebox.showwarning("Warning", "No mineral selected.")
            return
            
        self.manual_mineral_var.set(self.current_mineral)
        
        # Get current classification with metadata
        classification_data = self.hey_manager.get_classification(self.current_mineral, include_metadata=True)
        
        self.current_class_text.delete(1.0, tk.END)
        
        if classification_data:
            if isinstance(classification_data, dict):
                text = f"Current Classification for {self.current_mineral}:\n\n"
                text += f"Classification: {classification_data.get('classification', 'N/A')}\n"
                text += f"Confidence: {classification_data.get('confidence', 'N/A')}\n"
                text += f"Reasoning: {classification_data.get('reasoning', 'N/A')}\n"
                text += f"Source: {classification_data.get('source_file', 'N/A')}\n"
                text += f"Last Updated: {classification_data.get('last_updated', 'N/A')}\n"
            else:
                text = f"Classification: {classification_data}\n"
        else:
            text = f"No classification found for {self.current_mineral}"
            
        self.current_class_text.insert(tk.END, text)
        
    def export_hey_data(self, format):
        """Export Hey classification data."""
        file_path = filedialog.asksaveasfilename(
            title=f"Export Hey Classifications as {format.upper()}",
            defaultextension=f".{format}",
            filetypes=[(f"{format.upper()} files", f"*.{format}"), ("All files", "*.*")]
        )
        if file_path:
            try:
                self.hey_manager.export_data(file_path, format)
                messagebox.showinfo("Success", f"Data exported to {file_path}")
            except Exception as e:
                messagebox.showerror("Error", f"Export failed: {e}")
                
    def import_hey_data(self):
        """Import Hey classification data from CSV."""
        file_path = filedialog.askopenfilename(
            title="Import Hey Classifications",
            filetypes=[("CSV files", "*.csv"), ("All files", "*.*")]
        )
        if file_path:
            self.hey_manager.add_csv_source(file_path, priority=0)  # Add at highest priority
            self.reload_hey_data()
            
    def reload_all_hey_sources(self):
        """Reload all Hey classification sources."""
        self.hey_manager.load_all_data(force_reload=True)
        hey_classes = ["All"] + self.hey_manager.get_all_classifications()
        self.hey_combo['values'] = hey_classes
        
        # Update status
        stats = self.hey_manager.get_statistics()
        status_text = f"Reloaded {stats['total_minerals']} minerals with {stats['total_classifications']} classifications\n"
        status_text += f"Sources: {', '.join(stats['sources'])}\n"
        self.hey_status_text.delete(1.0, tk.END)
        self.hey_status_text.insert(tk.END, status_text)
        
        messagebox.showinfo("Success", "All Hey classification sources reloaded!")

def import_from_peak_fitting(peak_fitting_results, mineral_name, crystal_system=None, point_group=None, space_group=None):
    """
    Import data from peak_fitting.py results into the database.
    
    Parameters:
    -----------
    peak_fitting_results : dict
        Results from peak_fitting.py
    mineral_name : str
        Name of the mineral
    crystal_system : str, optional
        Crystal system
    point_group : str, optional
        Point group
    space_group : str, optional
        Space group
        
    Returns:
    --------
    bool
        True if successful, False otherwise
    """
    db = MineralDatabase()
    
    # Add mineral if it doesn't exist
    if mineral_name not in db.get_minerals():
        db.add_mineral(mineral_name, crystal_system, point_group, space_group)
    
    # Convert peak fitting results to database format
    peak_data = []
    for peak in peak_fitting_results.get('peaks', []):
        peak_data.append({
            'position': peak.get('center', 0),
            'amplitude': peak.get('amplitude', 1.0),
            'symmetry': peak.get('symmetry', 'A1g')  # Default symmetry
        })
    
    # Import peaks
    success = db.import_from_peak_fitting(mineral_name, peak_data)
    
    # Save database
    if success:
        db.save_database()
    
    return success

def update_point_group_notations():
    """
    Update all minerals in the database to add both Hermann-Mauguin and Schoenflies point group notations.
    - Derives point group from space group if not present
    - Converts from Hermann-Mauguin to Schoenflies 
    - Stores both notations in separate keys
    """
    db = MineralDatabase()
    
    # Hermann-Mauguin to Schoenflies mapping
    hm_to_schoenflies = {
        '1': 'C1', '-1': 'Ci',
        '2': 'C2', 'm': 'Cs', '2/m': 'C2h',
        '222': 'D2', 'mm2': 'C2v', 'mmm': 'D2h',
        '4': 'C4', '-4': 'S4', '4/m': 'C4h',
        '422': 'D4', '4mm': 'C4v', '-42m': 'D2d', '4/mmm': 'D4h',
        '3': 'C3', '-3': 'C3i',
        '32': 'D3', '3m': 'C3v', '-3m': 'D3d',
        '6': 'C6', '-6': 'C3h', '6/m': 'C6h',
        '622': 'D6', '6mm': 'C6v', '-62m': 'D3h', '6/mmm': 'D6h',
        '23': 'T', 'm-3': 'Th',
        '432': 'O', '-43m': 'Td', 'm-3m': 'Oh'
    }
    
    # Track statistics
    total_minerals = 0
    updated_count = 0
    failed_count = 0
    skipped_count = 0
    
    # Process each mineral
    for mineral_name in db.get_minerals():
        total_minerals += 1
        mineral_data = db.get_mineral_data(mineral_name)
        
        # Skip entries that are not dictionaries (like boolean values or special markers)
        if not isinstance(mineral_data, dict):
            print(f"Skipping {mineral_name}: Not a valid mineral data record (type: {type(mineral_data)})")
            skipped_count += 1
            continue
            
        if not mineral_data:
            print(f"Error: No data found for {mineral_name}")
            skipped_count += 1
            continue
            
        # Step 1: Get/derive point group in Hermann-Mauguin notation
        hm_point_group = ""
        
        # Check if there's already a point group stored
        current_pg = mineral_data.get('point_group', '')
        
        # If current point group looks like Schoenflies (has letters), try reverse lookup
        if current_pg and any(s in current_pg for s in ['C', 'D', 'T', 'O', 'I', 'S']):
            # Reverse lookup from Schoenflies to Hermann-Mauguin
            reversed_mapping = {v: k for k, v in hm_to_schoenflies.items()}
            if current_pg in reversed_mapping:
                hm_point_group = reversed_mapping[current_pg]
        else:
            # If already in Hermann-Mauguin format or empty
            hm_point_group = current_pg
        
        # If still no point group, try to derive from space group
        if not hm_point_group:
            space_group = mineral_data.get('space_group', '')
            if space_group:
                try:
                    # Handle numeric or string space groups
                    if isinstance(space_group, (int, float, np.integer, np.floating)):
                        # If it's a number, use the _derive_crystal_system to get crystal system
                        crystal_system = db._derive_crystal_system(space_group)
                        # Set a default point group based on the crystal system
                        if 'Triclinic' in crystal_system:
                            hm_point_group = '-1'
                        elif 'Monoclinic' in crystal_system:
                            hm_point_group = '2/m'
                        elif 'Orthorhombic' in crystal_system:
                            hm_point_group = 'mmm'
                        elif 'Tetragonal' in crystal_system:
                            hm_point_group = '4/mmm'
                        elif 'Trigonal' in crystal_system:
                            hm_point_group = '-3m'
                        elif 'Hexagonal' in crystal_system:
                            hm_point_group = '6/mmm'
                        elif 'Cubic' in crystal_system:
                            hm_point_group = 'm-3m'
                        else:
                            # Default for unknown
                            hm_point_group = '1'
                    else:
                        # String space group, use the existing derive function
                        derived_pg = db._derive_point_group(space_group)
                        if derived_pg:
                            hm_point_group = derived_pg
                except Exception as e:
                    print(f"Error deriving point group from space group for {mineral_name}: {e}")
        
        # Step 2: Convert Hermann-Mauguin to Schoenflies
        schoenflies_point_group = ""
        if hm_point_group in hm_to_schoenflies:
            schoenflies_point_group = hm_to_schoenflies[hm_point_group]
        
        # If still no valid point group, assign based on crystal system
        if not hm_point_group or not schoenflies_point_group:
            crystal_system = mineral_data.get('crystal_system', '').lower()
            
            if 'cubic' in crystal_system:
                hm_point_group = 'm-3m'
                schoenflies_point_group = 'Oh'
            elif 'hexagonal' in crystal_system:
                hm_point_group = '6/mmm'
                schoenflies_point_group = 'D6h'
            elif 'trigonal' in crystal_system:
                hm_point_group = '-3m'
                schoenflies_point_group = 'D3d'
            elif 'tetragonal' in crystal_system:
                hm_point_group = '4/mmm'
                schoenflies_point_group = 'D4h'
            elif 'orthorhombic' in crystal_system:
                hm_point_group = 'mmm'
                schoenflies_point_group = 'D2h'
            elif 'monoclinic' in crystal_system:
                hm_point_group = '2/m'
                schoenflies_point_group = 'C2h'
            elif 'triclinic' in crystal_system:
                hm_point_group = '-1'
                schoenflies_point_group = 'Ci'
            else:
                # If all else fails, set to lowest symmetry
                hm_point_group = '1'
                schoenflies_point_group = 'C1'
        
        # Step 3: Update the mineral data with both notations
        if hm_point_group and schoenflies_point_group:
            mineral_data['hermann_mauguin_point_group'] = hm_point_group
            mineral_data['schoenflies_point_group'] = schoenflies_point_group
            
            # Keep the original point_group field with Schoenflies for compatibility
            mineral_data['point_group'] = schoenflies_point_group
            
            updated_count += 1
            print(f"Updated {mineral_name}: {hm_point_group} (HM) → {schoenflies_point_group} (Schoenflies)")
        else:
            failed_count += 1
            print(f"Failed to determine point group for {mineral_name}")
    
    # Save the database
    if updated_count > 0:
        success = db.save_database()
        if success:
            print(f"Database saved successfully.")
        else:
            print(f"Failed to save database.")
    
    # Print summary
    print(f"\nSummary:")
    print(f"Total minerals: {total_minerals}")
    print(f"Updated with both notations: {updated_count}")
    print(f"Failed to determine point groups: {failed_count}")
    print(f"Skipped entries: {skipped_count}")
    
    return updated_count > 0

class HeyClassificationManager:
    """
    Comprehensive manager for Hey-Celestian classification system.
    Provides flexible, updateable, and robust classification handling.
    """
    
    def __init__(self, database_dir=None):
        """Initialize the Hey classification manager."""
        self.database_dir = database_dir or os.path.dirname(__file__)
        self.classification_data = {}
        self.classification_cache = {}
        self.config = self._load_config()
        self.last_update = None
        self.validation_rules = self._load_validation_rules()
        
    def _load_config(self):
        """Load configuration for Hey classification system."""
        default_config = {
            'csv_search_paths': [
                'RRUFF_Export_with_Hey_Classification.csv',
                'Hey_class/RRUFF_Export_20250503_222156_Hey_Celestian.csv',
                'Hey_class/hey_improved_classification.csv',
                'RRUFF_Hey_Index.csv',
                'Hey_class/RRUFF_Hey_Index.csv'
            ],
            'column_mappings': {
                'mineral_name': ['Mineral Name', 'Mineral_Name', 'mineral_name', 'Name'],
                'hey_classification': ['Hey-Celestian Group Name', 'Hey_Classification', 'Hey Classification', 'Classification'],
                'confidence': ['Hey-Celestian Confidence', 'Confidence', 'confidence'],
                'reasoning': ['Hey-Celestian Reasoning', 'Reasoning', 'reasoning']
            },
            'cache_timeout': 3600,  # 1 hour in seconds
            'auto_update': True,
            'validation_enabled': True,
            'fallback_classification': 'Unclassified',
            'min_confidence_threshold': 0.0
        }
        
        # Try to load custom config file
        config_path = os.path.join(self.database_dir, 'hey_classification_config.json')
        if os.path.exists(config_path):
            try:
                with open(config_path, 'r') as f:
                    custom_config = json.load(f)
                    default_config.update(custom_config)
                    print(f"Loaded custom Hey classification config from {config_path}")
            except Exception as e:
                print(f"Error loading config file: {e}, using defaults")
        
        return default_config
        
    def _load_validation_rules(self):
        """Load validation rules for Hey classifications."""
        return {
            'valid_classifications': set(),  # Will be populated from data
            'required_fields': ['mineral_name', 'hey_classification'],
            'optional_fields': ['confidence', 'reasoning'],
            'name_cleaning_rules': [
                (r'\s+', ' '),  # Multiple spaces to single space
                (r'[^\w\s\-\(\)]', ''),  # Remove special characters except hyphens and parentheses
                (r'^\s+|\s+$', ''),  # Trim whitespace
            ]
        }
        
    def save_config(self):
        """Save current configuration to file."""
        config_path = os.path.join(self.database_dir, 'hey_classification_config.json')
        try:
            with open(config_path, 'w') as f:
                json.dump(self.config, f, indent=2)
            print(f"Saved Hey classification config to {config_path}")
            return True
        except Exception as e:
            print(f"Error saving config: {e}")
            return False
            
    def add_csv_source(self, csv_path, priority=None):
        """Add a new CSV source to the search paths."""
        if priority is None:
            self.config['csv_search_paths'].append(csv_path)
        else:
            self.config['csv_search_paths'].insert(priority, csv_path)
        self.save_config()
        self._invalidate_cache()
        
    def remove_csv_source(self, csv_path):
        """Remove a CSV source from the search paths."""
        if csv_path in self.config['csv_search_paths']:
            self.config['csv_search_paths'].remove(csv_path)
            self.save_config()
            self._invalidate_cache()
            
    def _invalidate_cache(self):
        """Invalidate the classification cache."""
        self.classification_cache.clear()
        self.classification_data.clear()
        self.last_update = None
        
    def _clean_mineral_name(self, name):
        """Clean mineral name using configured rules."""
        if not name:
            return ""
            
        cleaned = str(name).strip()
        for pattern, replacement in self.validation_rules['name_cleaning_rules']:
            import re
            cleaned = re.sub(pattern, replacement, cleaned)
        return cleaned
        
    def _find_csv_files(self):
        """Find available CSV files from configured paths."""
        found_files = []
        
        for csv_path in self.config['csv_search_paths']:
            # Try absolute path first
            if os.path.isabs(csv_path) and os.path.exists(csv_path):
                found_files.append(csv_path)
                continue
                
            # Try relative to database directory
            full_path = os.path.join(self.database_dir, csv_path)
            if os.path.exists(full_path):
                found_files.append(full_path)
                continue
                
            # Try in current directory
            if os.path.exists(csv_path):
                found_files.append(csv_path)
                continue
                
            # Try in home directory
            home_path = os.path.join(os.path.expanduser("~"), os.path.basename(csv_path))
            if os.path.exists(home_path):
                found_files.append(home_path)
                
        return found_files
        
    def _load_csv_data(self, csv_path):
        """Load and parse CSV data with flexible column mapping."""
        try:
            df = pd.read_csv(csv_path)
            print(f"Loading Hey classification data from {csv_path}")
            print(f"CSV columns: {list(df.columns)}")
            
            # Find column mappings
            column_map = {}
            for field, possible_names in self.config['column_mappings'].items():
                for col_name in possible_names:
                    if col_name in df.columns:
                        column_map[field] = col_name
                        break
                        
            if 'mineral_name' not in column_map or 'hey_classification' not in column_map:
                print(f"Required columns not found in {csv_path}")
                print(f"Found mappings: {column_map}")
                return {}
                
            # Extract data
            data = {}
            for _, row in df.iterrows():
                try:
                    mineral_name = self._clean_mineral_name(row[column_map['mineral_name']])
                    classification = str(row[column_map['hey_classification']]).strip()
                    
                    if not mineral_name or not classification or pd.isna(classification):
                        continue
                        
                    # Build classification record
                    record = {
                        'classification': classification,
                        'source_file': os.path.basename(csv_path),
                        'last_updated': time.time()
                    }
                    
                    # Add optional fields if available
                    if 'confidence' in column_map and column_map['confidence'] in row:
                        try:
                            confidence = float(row[column_map['confidence']])
                            record['confidence'] = confidence
                        except (ValueError, TypeError):
                            pass
                            
                    if 'reasoning' in column_map and column_map['reasoning'] in row:
                        reasoning = str(row[column_map['reasoning']]).strip()
                        if reasoning and not pd.isna(reasoning):
                            record['reasoning'] = reasoning
                            
                    # Store with both original and cleaned names
                    data[mineral_name] = record
                    
                    # Also store with uppercase for case-insensitive lookup
                    data[mineral_name.upper()] = record
                    
                except Exception as e:
                    continue
                    
            print(f"Loaded {len(data)//2} mineral classifications from {csv_path}")
            return data
            
        except Exception as e:
            print(f"Error loading CSV {csv_path}: {e}")
            return {}
            
    def load_all_data(self, force_reload=False):
        """Load all classification data from available sources."""
        # Check cache validity
        if (not force_reload and self.classification_data and self.last_update and 
            time.time() - self.last_update < self.config['cache_timeout']):
            return self.classification_data
            
        print("Loading Hey-Celestian classification data...")
        self.classification_data.clear()
        
        csv_files = self._find_csv_files()
        if not csv_files:
            print("No Hey classification CSV files found")
            return {}
            
        # Load data from all sources (later sources override earlier ones)
        for csv_path in csv_files:
            csv_data = self._load_csv_data(csv_path)
            self.classification_data.update(csv_data)
            
        # Update validation rules with found classifications
        classifications = set()
        for record in self.classification_data.values():
            if isinstance(record, dict) and 'classification' in record:
                classifications.add(record['classification'])
        self.validation_rules['valid_classifications'] = classifications
        
        self.last_update = time.time()
        print(f"Total unique classifications loaded: {len(classifications)}")
        print(f"Sample classifications: {list(classifications)[:5]}")
        
        return self.classification_data
        
    def get_classification(self, mineral_name, include_metadata=False):
        """Get Hey classification for a mineral with flexible matching."""
        if not mineral_name:
            return None
            
        # Ensure data is loaded
        if not self.classification_data:
            self.load_all_data()
            
        # Clean the input name
        cleaned_name = self._clean_mineral_name(mineral_name)
        
        # Try exact matches first
        for name_variant in [mineral_name, cleaned_name, mineral_name.upper(), cleaned_name.upper()]:
            if name_variant in self.classification_data:
                record = self.classification_data[name_variant]
                if include_metadata:
                    return record
                return record.get('classification') if isinstance(record, dict) else record
                
        # Try partial matches
        for stored_name, record in self.classification_data.items():
            if (cleaned_name.upper() in stored_name.upper() or 
                stored_name.upper() in cleaned_name.upper()):
                if include_metadata:
                    return record
                return record.get('classification') if isinstance(record, dict) else record
                
        return None
        
    def get_all_classifications(self):
        """Get list of all available classifications."""
        if not self.classification_data:
            self.load_all_data()
        return sorted(list(self.validation_rules['valid_classifications']))
        
    def add_classification(self, mineral_name, classification, confidence=None, reasoning=None, source="manual"):
        """Add or update a classification manually."""
        cleaned_name = self._clean_mineral_name(mineral_name)
        
        record = {
            'classification': classification,
            'source_file': source,
            'last_updated': time.time()
        }
        
        if confidence is not None:
            record['confidence'] = float(confidence)
        if reasoning:
            record['reasoning'] = str(reasoning)
            
        # Store with both original and cleaned names
        self.classification_data[cleaned_name] = record
        self.classification_data[cleaned_name.upper()] = record
        
        # Update validation rules
        self.validation_rules['valid_classifications'].add(classification)
        
        # Save to custom file
        self._save_custom_classifications()
        
    def _save_custom_classifications(self):
        """Save manually added classifications to a custom file."""
        custom_file = os.path.join(self.database_dir, 'custom_hey_classifications.json')
        
        # Extract manual classifications
        manual_data = {}
        for name, record in self.classification_data.items():
            if isinstance(record, dict) and record.get('source_file') == 'manual':
                manual_data[name] = record
                
        try:
            with open(custom_file, 'w') as f:
                json.dump(manual_data, f, indent=2)
            print(f"Saved {len(manual_data)} custom classifications to {custom_file}")
        except Exception as e:
            print(f"Error saving custom classifications: {e}")
            
    def validate_classification(self, classification):
        """Validate a classification against known values."""
        if not self.config['validation_enabled']:
            return True, "Validation disabled"
            
        if not self.validation_rules['valid_classifications']:
            return True, "No validation data available"
            
        if classification in self.validation_rules['valid_classifications']:
            return True, "Valid classification"
            
        # Suggest similar classifications
        similar = []
        for valid_class in self.validation_rules['valid_classifications']:
            if classification.lower() in valid_class.lower() or valid_class.lower() in classification.lower():
                similar.append(valid_class)
                
        if similar:
            return False, f"Unknown classification. Similar: {', '.join(similar[:3])}"
        else:
            return False, "Unknown classification"
            
    def get_statistics(self):
        """Get statistics about the classification data."""
        if not self.classification_data:
            self.load_all_data()
            
        stats = {
            'total_minerals': len(set(k for k in self.classification_data.keys() if not k.isupper())),
            'total_classifications': len(self.validation_rules['valid_classifications']),
            'sources': set(),
            'confidence_stats': {'min': None, 'max': None, 'avg': None, 'count': 0},
            'classification_counts': {}
        }
        
        confidences = []
        for record in self.classification_data.values():
            if isinstance(record, dict):
                if 'source_file' in record:
                    stats['sources'].add(record['source_file'])
                if 'confidence' in record:
                    confidences.append(record['confidence'])
                if 'classification' in record:
                    cls = record['classification']
                    stats['classification_counts'][cls] = stats['classification_counts'].get(cls, 0) + 1
                    
        if confidences:
            stats['confidence_stats'] = {
                'min': min(confidences),
                'max': max(confidences),
                'avg': sum(confidences) / len(confidences),
                'count': len(confidences)
            }
            
        stats['sources'] = list(stats['sources'])
        return stats
        
    def export_data(self, output_path, format='csv'):
        """Export classification data to file."""
        if not self.classification_data:
            self.load_all_data()
            
        # Prepare data for export
        export_data = []
        processed_names = set()
        
        for name, record in self.classification_data.items():
            # Skip uppercase duplicates
            if name.isupper() and name.lower() in processed_names:
                continue
                
            if isinstance(record, dict):
                row = {
                    'Mineral_Name': name,
                    'Hey_Classification': record.get('classification', ''),
                    'Confidence': record.get('confidence', ''),
                    'Reasoning': record.get('reasoning', ''),
                    'Source_File': record.get('source_file', ''),
                    'Last_Updated': record.get('last_updated', '')
                }
                export_data.append(row)
                processed_names.add(name.lower())
                
        if format.lower() == 'csv':
            df = pd.DataFrame(export_data)
            df.to_csv(output_path, index=False)
        elif format.lower() == 'json':
            with open(output_path, 'w') as f:
                json.dump(export_data, f, indent=2)
        else:
            raise ValueError(f"Unsupported format: {format}")
            
        print(f"Exported {len(export_data)} classifications to {output_path}")
        return True

if __name__ == "__main__":
    import sys

    
    # Check if an argument is passed
    if len(sys.argv) > 1 and sys.argv[1] == '--update-point-groups':
        # Only update point group notations
        print("Checking and updating point group notations in the database...")
        update_point_group_notations()
        print("Point group update completed. You can now run the program normally.")
        sys.exit(0)
    elif len(sys.argv) > 1 and sys.argv[1] == '--help':
        print("Usage:")
        print("  python mineral_database.py            - Run the GUI")
        print("  python mineral_database.py --update-point-groups - Update point groups in database")
        sys.exit(0)
    else:
        # Run the GUI as normal
        app = MineralDatabaseGUI()
        app.run()